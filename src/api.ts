/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Nomad
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.1.4
 * Contact: support@hashicorp.com
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "{scheme}://{address}:{port}/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ACLPolicy
 */
export interface ACLPolicy {
    /**
     * 
     * @type {number}
     * @memberof ACLPolicy
     */
    createIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof ACLPolicy
     */
    description?: string;
    /**
     * 
     * @type {JobACL}
     * @memberof ACLPolicy
     */
    jobACL?: JobACL;
    /**
     * 
     * @type {number}
     * @memberof ACLPolicy
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof ACLPolicy
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ACLPolicy
     */
    rules?: string;
}
/**
 * 
 * @export
 * @interface ACLPolicyListStub
 */
export interface ACLPolicyListStub {
    /**
     * 
     * @type {number}
     * @memberof ACLPolicyListStub
     */
    createIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof ACLPolicyListStub
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ACLPolicyListStub
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof ACLPolicyListStub
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ACLToken
 */
export interface ACLToken {
    /**
     * 
     * @type {string}
     * @memberof ACLToken
     */
    accessorID?: string;
    /**
     * 
     * @type {number}
     * @memberof ACLToken
     */
    createIndex?: number;
    /**
     * 
     * @type {Date}
     * @memberof ACLToken
     */
    createTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof ACLToken
     */
    expirationTTL?: number;
    /**
     * 
     * @type {Date}
     * @memberof ACLToken
     */
    expirationTime?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof ACLToken
     */
    global?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ACLToken
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof ACLToken
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ACLToken
     */
    policies?: Array<string>;
    /**
     * 
     * @type {Array<ACLTokenRoleLink>}
     * @memberof ACLToken
     */
    roles?: Array<ACLTokenRoleLink>;
    /**
     * 
     * @type {string}
     * @memberof ACLToken
     */
    secretID?: string;
    /**
     * 
     * @type {string}
     * @memberof ACLToken
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface ACLTokenListStub
 */
export interface ACLTokenListStub {
    /**
     * 
     * @type {string}
     * @memberof ACLTokenListStub
     */
    accessorID?: string;
    /**
     * 
     * @type {number}
     * @memberof ACLTokenListStub
     */
    createIndex?: number;
    /**
     * 
     * @type {Date}
     * @memberof ACLTokenListStub
     */
    createTime?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof ACLTokenListStub
     */
    global?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ACLTokenListStub
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof ACLTokenListStub
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ACLTokenListStub
     */
    policies?: Array<string>;
    /**
     * 
     * @type {Array<ACLTokenRoleLink>}
     * @memberof ACLTokenListStub
     */
    roles?: Array<ACLTokenRoleLink>;
    /**
     * 
     * @type {string}
     * @memberof ACLTokenListStub
     */
    type?: string;
    /**
     * 
     * @type {Date}
     * @memberof ACLTokenListStub
     */
    expirationTime?: Date;
}
/**
 * 
 * @export
 * @interface ACLTokenRoleLink
 */
export interface ACLTokenRoleLink {
    /**
     * 
     * @type {string}
     * @memberof ACLTokenRoleLink
     */
    ID?: string;
    /**
     * 
     * @type {string}
     * @memberof ACLTokenRoleLink
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Affinity
 */
export interface Affinity {
    /**
     * 
     * @type {string}
     * @memberof Affinity
     */
    lTarget?: string;
    /**
     * 
     * @type {string}
     * @memberof Affinity
     */
    operand?: string;
    /**
     * 
     * @type {string}
     * @memberof Affinity
     */
    rTarget?: string;
    /**
     * 
     * @type {number}
     * @memberof Affinity
     */
    weight?: number;
}
/**
 * 
 * @export
 * @interface AllocDeploymentStatus
 */
export interface AllocDeploymentStatus {
    /**
     * 
     * @type {boolean}
     * @memberof AllocDeploymentStatus
     */
    canary?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AllocDeploymentStatus
     */
    healthy?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AllocDeploymentStatus
     */
    modifyIndex?: number;
    /**
     * 
     * @type {Date}
     * @memberof AllocDeploymentStatus
     */
    timestamp?: Date;
}
/**
 * 
 * @export
 * @interface AllocStopResponse
 */
export interface AllocStopResponse {
    /**
     * 
     * @type {string}
     * @memberof AllocStopResponse
     */
    evalID?: string;
    /**
     * 
     * @type {number}
     * @memberof AllocStopResponse
     */
    index?: number;
}
/**
 * 
 * @export
 * @interface AllocatedCpuResources
 */
export interface AllocatedCpuResources {
    /**
     * 
     * @type {number}
     * @memberof AllocatedCpuResources
     */
    cpuShares?: number;
}
/**
 * 
 * @export
 * @interface AllocatedDeviceResource
 */
export interface AllocatedDeviceResource {
    /**
     * 
     * @type {Array<string>}
     * @memberof AllocatedDeviceResource
     */
    deviceIDs?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AllocatedDeviceResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AllocatedDeviceResource
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof AllocatedDeviceResource
     */
    vendor?: string;
}
/**
 * 
 * @export
 * @interface AllocatedMemoryResources
 */
export interface AllocatedMemoryResources {
    /**
     * 
     * @type {number}
     * @memberof AllocatedMemoryResources
     */
    memoryMB?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocatedMemoryResources
     */
    memoryMaxMB?: number;
}
/**
 * 
 * @export
 * @interface AllocatedResources
 */
export interface AllocatedResources {
    /**
     * 
     * @type {AllocatedSharedResources}
     * @memberof AllocatedResources
     */
    shared?: AllocatedSharedResources;
    /**
     * 
     * @type {{ [key: string]: AllocatedTaskResources; }}
     * @memberof AllocatedResources
     */
    tasks?: { [key: string]: AllocatedTaskResources; };
}
/**
 * 
 * @export
 * @interface AllocatedSharedResources
 */
export interface AllocatedSharedResources {
    /**
     * 
     * @type {number}
     * @memberof AllocatedSharedResources
     */
    diskMB?: number;
    /**
     * 
     * @type {Array<NetworkResource>}
     * @memberof AllocatedSharedResources
     */
    networks?: Array<NetworkResource>;
    /**
     * 
     * @type {Array<PortMapping>}
     * @memberof AllocatedSharedResources
     */
    ports?: Array<PortMapping>;
}
/**
 * 
 * @export
 * @interface AllocatedTaskResources
 */
export interface AllocatedTaskResources {
    /**
     * 
     * @type {AllocatedCpuResources}
     * @memberof AllocatedTaskResources
     */
    cpu?: AllocatedCpuResources;
    /**
     * 
     * @type {Array<AllocatedDeviceResource>}
     * @memberof AllocatedTaskResources
     */
    devices?: Array<AllocatedDeviceResource>;
    /**
     * 
     * @type {AllocatedMemoryResources}
     * @memberof AllocatedTaskResources
     */
    memory?: AllocatedMemoryResources;
    /**
     * 
     * @type {Array<NetworkResource>}
     * @memberof AllocatedTaskResources
     */
    networks?: Array<NetworkResource>;
}
/**
 * 
 * @export
 * @interface Allocation
 */
export interface Allocation {
    /**
     * 
     * @type {number}
     * @memberof Allocation
     */
    allocModifyIndex?: number;
    /**
     * 
     * @type {AllocatedResources}
     * @memberof Allocation
     */
    allocatedResources?: AllocatedResources;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    clientDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    clientStatus?: string;
    /**
     * 
     * @type {number}
     * @memberof Allocation
     */
    createIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof Allocation
     */
    createTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    deploymentID?: string;
    /**
     * 
     * @type {AllocDeploymentStatus}
     * @memberof Allocation
     */
    deploymentStatus?: AllocDeploymentStatus;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    desiredDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    desiredStatus?: string;
    /**
     * 
     * @type {DesiredTransition}
     * @memberof Allocation
     */
    desiredTransition?: DesiredTransition;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    evalID?: string;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    followupEvalID?: string;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    ID?: string;
    /**
     * 
     * @type {Job}
     * @memberof Allocation
     */
    job?: Job;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    jobID?: string;
    /**
     * 
     * @type {AllocationMetric}
     * @memberof Allocation
     */
    metrics?: AllocationMetric;
    /**
     * 
     * @type {number}
     * @memberof Allocation
     */
    modifyIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof Allocation
     */
    modifyTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    nextAllocation?: string;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    nodeID?: string;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    nodeName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Allocation
     */
    preemptedAllocations?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    preemptedByAllocation?: string;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    previousAllocation?: string;
    /**
     * 
     * @type {RescheduleTracker}
     * @memberof Allocation
     */
    rescheduleTracker?: RescheduleTracker;
    /**
     * 
     * @type {Resources}
     * @memberof Allocation
     */
    resources?: Resources;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Allocation
     */
    services?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    taskGroup?: string;
    /**
     * 
     * @type {{ [key: string]: Resources; }}
     * @memberof Allocation
     */
    taskResources?: { [key: string]: Resources; };
    /**
     * 
     * @type {{ [key: string]: TaskState; }}
     * @memberof Allocation
     */
    taskStates?: { [key: string]: TaskState; };
}
/**
 * 
 * @export
 * @interface AllocationListStub
 */
export interface AllocationListStub {
    /**
     * 
     * @type {AllocatedResources}
     * @memberof AllocationListStub
     */
    allocatedResources?: AllocatedResources;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    clientDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    clientStatus?: string;
    /**
     * 
     * @type {number}
     * @memberof AllocationListStub
     */
    createIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationListStub
     */
    createTime?: number;
    /**
     * 
     * @type {AllocDeploymentStatus}
     * @memberof AllocationListStub
     */
    deploymentStatus?: AllocDeploymentStatus;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    desiredDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    desiredStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    evalID?: string;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    followupEvalID?: string;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    ID?: string;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    jobID?: string;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    jobType?: string;
    /**
     * 
     * @type {number}
     * @memberof AllocationListStub
     */
    jobVersion?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationListStub
     */
    modifyIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationListStub
     */
    modifyTime?: number;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    nodeID?: string;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    nodeName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AllocationListStub
     */
    preemptedAllocations?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    preemptedByAllocation?: string;
    /**
     * 
     * @type {RescheduleTracker}
     * @memberof AllocationListStub
     */
    rescheduleTracker?: RescheduleTracker;
    /**
     * 
     * @type {string}
     * @memberof AllocationListStub
     */
    taskGroup?: string;
    /**
     * 
     * @type {{ [key: string]: TaskState; }}
     * @memberof AllocationListStub
     */
    taskStates?: { [key: string]: TaskState; };
}
/**
 * 
 * @export
 * @interface AllocationMetric
 */
export interface AllocationMetric {
    /**
     * 
     * @type {number}
     * @memberof AllocationMetric
     */
    allocationTime?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof AllocationMetric
     */
    classExhausted?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof AllocationMetric
     */
    classFiltered?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof AllocationMetric
     */
    coalescedFailures?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof AllocationMetric
     */
    constraintFiltered?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof AllocationMetric
     */
    dimensionExhausted?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof AllocationMetric
     */
    nodesAvailable?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof AllocationMetric
     */
    nodesEvaluated?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationMetric
     */
    nodesExhausted?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationMetric
     */
    nodesFiltered?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AllocationMetric
     */
    quotaExhausted?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: Resources; }}
     * @memberof AllocationMetric
     */
    resourcesExhausted?: { [key: string]: Resources; };
    /**
     * 
     * @type {Array<NodeScoreMeta>}
     * @memberof AllocationMetric
     */
    scoreMetaData?: Array<NodeScoreMeta>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof AllocationMetric
     */
    scores?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * 
     * @type {boolean}
     * @memberof Attribute
     */
    bool?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Attribute
     */
    _float?: number;
    /**
     * 
     * @type {number}
     * @memberof Attribute
     */
    _int?: number;
    /**
     * 
     * @type {string}
     * @memberof Attribute
     */
    string?: string;
    /**
     * 
     * @type {string}
     * @memberof Attribute
     */
    unit?: string;
}
/**
 * 
 * @export
 * @interface AutopilotConfiguration
 */
export interface AutopilotConfiguration {
    /**
     * 
     * @type {boolean}
     * @memberof AutopilotConfiguration
     */
    cleanupDeadServers?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AutopilotConfiguration
     */
    createIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AutopilotConfiguration
     */
    disableUpgradeMigration?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AutopilotConfiguration
     */
    enableCustomUpgrades?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AutopilotConfiguration
     */
    enableRedundancyZones?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AutopilotConfiguration
     */
    lastContactThreshold?: string;
    /**
     * 
     * @type {number}
     * @memberof AutopilotConfiguration
     */
    maxTrailingLogs?: number;
    /**
     * 
     * @type {number}
     * @memberof AutopilotConfiguration
     */
    minQuorum?: number;
    /**
     * 
     * @type {number}
     * @memberof AutopilotConfiguration
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof AutopilotConfiguration
     */
    serverStabilizationTime?: string;
}
/**
 * 
 * @export
 * @interface CSIControllerInfo
 */
export interface CSIControllerInfo {
    /**
     * 
     * @type {boolean}
     * @memberof CSIControllerInfo
     */
    supportsAttachDetach?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSIControllerInfo
     */
    supportsClone?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSIControllerInfo
     */
    supportsCondition?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSIControllerInfo
     */
    supportsCreateDelete?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSIControllerInfo
     */
    supportsCreateDeleteSnapshot?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSIControllerInfo
     */
    supportsExpand?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSIControllerInfo
     */
    supportsGet?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSIControllerInfo
     */
    supportsGetCapacity?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSIControllerInfo
     */
    supportsListSnapshots?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSIControllerInfo
     */
    supportsListVolumes?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSIControllerInfo
     */
    supportsListVolumesAttachedNodes?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSIControllerInfo
     */
    supportsReadOnlyAttach?: boolean;
}
/**
 * 
 * @export
 * @interface CSIInfo
 */
export interface CSIInfo {
    /**
     * 
     * @type {string}
     * @memberof CSIInfo
     */
    allocID?: string;
    /**
     * 
     * @type {CSIControllerInfo}
     * @memberof CSIInfo
     */
    controllerInfo?: CSIControllerInfo;
    /**
     * 
     * @type {string}
     * @memberof CSIInfo
     */
    healthDescription?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CSIInfo
     */
    healthy?: boolean;
    /**
     * 
     * @type {CSINodeInfo}
     * @memberof CSIInfo
     */
    nodeInfo?: CSINodeInfo;
    /**
     * 
     * @type {string}
     * @memberof CSIInfo
     */
    pluginID?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CSIInfo
     */
    requiresControllerPlugin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSIInfo
     */
    requiresTopologies?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof CSIInfo
     */
    updateTime?: Date;
}
/**
 * 
 * @export
 * @interface CSIMountOptions
 */
export interface CSIMountOptions {
    /**
     * 
     * @type {string}
     * @memberof CSIMountOptions
     */
    fSType?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CSIMountOptions
     */
    mountFlags?: Array<string>;
}
/**
 * 
 * @export
 * @interface CSINodeInfo
 */
export interface CSINodeInfo {
    /**
     * 
     * @type {CSITopology}
     * @memberof CSINodeInfo
     */
    accessibleTopology?: CSITopology;
    /**
     * 
     * @type {string}
     * @memberof CSINodeInfo
     */
    ID?: string;
    /**
     * 
     * @type {number}
     * @memberof CSINodeInfo
     */
    maxVolumes?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CSINodeInfo
     */
    requiresNodeStageVolume?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSINodeInfo
     */
    supportsCondition?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSINodeInfo
     */
    supportsExpand?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CSINodeInfo
     */
    supportsStats?: boolean;
}
/**
 * 
 * @export
 * @interface CSIPlugin
 */
export interface CSIPlugin {
    /**
     * 
     * @type {Array<AllocationListStub>}
     * @memberof CSIPlugin
     */
    allocations?: Array<AllocationListStub>;
    /**
     * 
     * @type {boolean}
     * @memberof CSIPlugin
     */
    controllerRequired?: boolean;
    /**
     * 
     * @type {{ [key: string]: CSIInfo; }}
     * @memberof CSIPlugin
     */
    controllers?: { [key: string]: CSIInfo; };
    /**
     * 
     * @type {number}
     * @memberof CSIPlugin
     */
    controllersExpected?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIPlugin
     */
    controllersHealthy?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIPlugin
     */
    createIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof CSIPlugin
     */
    ID?: string;
    /**
     * 
     * @type {number}
     * @memberof CSIPlugin
     */
    modifyIndex?: number;
    /**
     * 
     * @type {{ [key: string]: CSIInfo; }}
     * @memberof CSIPlugin
     */
    nodes?: { [key: string]: CSIInfo; };
    /**
     * 
     * @type {number}
     * @memberof CSIPlugin
     */
    nodesExpected?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIPlugin
     */
    nodesHealthy?: number;
    /**
     * 
     * @type {string}
     * @memberof CSIPlugin
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIPlugin
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface CSIPluginListStub
 */
export interface CSIPluginListStub {
    /**
     * 
     * @type {boolean}
     * @memberof CSIPluginListStub
     */
    controllerRequired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CSIPluginListStub
     */
    controllersExpected?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIPluginListStub
     */
    controllersHealthy?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIPluginListStub
     */
    createIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof CSIPluginListStub
     */
    ID?: string;
    /**
     * 
     * @type {number}
     * @memberof CSIPluginListStub
     */
    modifyIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIPluginListStub
     */
    nodesExpected?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIPluginListStub
     */
    nodesHealthy?: number;
    /**
     * 
     * @type {string}
     * @memberof CSIPluginListStub
     */
    provider?: string;
}
/**
 * 
 * @export
 */
export type CSIPluginType = string
/**
 * 
 * @export
 * @interface CSISecrets
 */
export interface CSISecrets extends Record<string, string> {
    [key: string]: string;

}
/**
 * 
 * @export
 * @interface CSISnapshot
 */
export interface CSISnapshot {
    /**
     * 
     * @type {number}
     * @memberof CSISnapshot
     */
    createTime?: number;
    /**
     * 
     * @type {string}
     * @memberof CSISnapshot
     */
    externalSourceVolumeID?: string;
    /**
     * 
     * @type {string}
     * @memberof CSISnapshot
     */
    ID?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CSISnapshot
     */
    isReady?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CSISnapshot
     */
    name?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CSISnapshot
     */
    parameters?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CSISnapshot
     */
    pluginID?: string;
    /**
     * 
     * @type {CSISecrets}
     * @memberof CSISnapshot
     */
    secrets?: CSISecrets;
    /**
     * 
     * @type {number}
     * @memberof CSISnapshot
     */
    sizeBytes?: number;
    /**
     * 
     * @type {string}
     * @memberof CSISnapshot
     */
    sourceVolumeID?: string;
}
/**
 * 
 * @export
 * @interface CSISnapshotCreateRequest
 */
export interface CSISnapshotCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof CSISnapshotCreateRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof CSISnapshotCreateRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof CSISnapshotCreateRequest
     */
    secretID?: string;
    /**
     * 
     * @type {Array<CSISnapshot>}
     * @memberof CSISnapshotCreateRequest
     */
    snapshots?: Array<CSISnapshot>;
}
/**
 * 
 * @export
 * @interface CSISnapshotCreateResponse
 */
export interface CSISnapshotCreateResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CSISnapshotCreateResponse
     */
    knownLeader?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CSISnapshotCreateResponse
     */
    lastContact?: number;
    /**
     * 
     * @type {number}
     * @memberof CSISnapshotCreateResponse
     */
    lastIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof CSISnapshotCreateResponse
     */
    nextToken?: string;
    /**
     * 
     * @type {number}
     * @memberof CSISnapshotCreateResponse
     */
    requestTime?: number;
    /**
     * 
     * @type {Array<CSISnapshot>}
     * @memberof CSISnapshotCreateResponse
     */
    snapshots?: Array<CSISnapshot>;
}
/**
 * 
 * @export
 * @interface CSISnapshotListResponse
 */
export interface CSISnapshotListResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CSISnapshotListResponse
     */
    knownLeader?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CSISnapshotListResponse
     */
    lastContact?: number;
    /**
     * 
     * @type {number}
     * @memberof CSISnapshotListResponse
     */
    lastIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof CSISnapshotListResponse
     */
    nextToken?: string;
    /**
     * 
     * @type {number}
     * @memberof CSISnapshotListResponse
     */
    requestTime?: number;
    /**
     * 
     * @type {Array<CSISnapshot>}
     * @memberof CSISnapshotListResponse
     */
    snapshots?: Array<CSISnapshot>;
}
/**
 * 
 * @export
 * @interface CSITopology
 */
export interface CSITopology {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CSITopology
     */
    segments?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CSITopologyRequest
 */
export interface CSITopologyRequest {
    /**
     * 
     * @type {Array<CSITopology>}
     * @memberof CSITopologyRequest
     */
    preferred?: Array<CSITopology>;
    /**
     * 
     * @type {Array<CSITopology>}
     * @memberof CSITopologyRequest
     */
    required?: Array<CSITopology>;
}
/**
 * 
 * @export
 * @interface CSIVolume
 */
export interface CSIVolume {
    /**
     * 
     * @type {string}
     * @memberof CSIVolume
     */
    accessMode?: string;
    /**
     * 
     * @type {Array<AllocationListStub>}
     * @memberof CSIVolume
     */
    allocations?: Array<AllocationListStub>;
    /**
     * 
     * @type {string}
     * @memberof CSIVolume
     */
    attachmentMode?: string;
    /**
     * 
     * @type {number}
     * @memberof CSIVolume
     */
    capacity?: number;
    /**
     * 
     * @type {string}
     * @memberof CSIVolume
     */
    cloneID?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CSIVolume
     */
    context?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof CSIVolume
     */
    controllerRequired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CSIVolume
     */
    controllersExpected?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIVolume
     */
    controllersHealthy?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIVolume
     */
    createIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof CSIVolume
     */
    externalID?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolume
     */
    ID?: string;
    /**
     * 
     * @type {number}
     * @memberof CSIVolume
     */
    modifyIndex?: number;
    /**
     * 
     * @type {CSIMountOptions}
     * @memberof CSIVolume
     */
    mountOptions?: CSIMountOptions;
    /**
     * 
     * @type {string}
     * @memberof CSIVolume
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolume
     */
    namespace?: string;
    /**
     * 
     * @type {number}
     * @memberof CSIVolume
     */
    nodesExpected?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIVolume
     */
    nodesHealthy?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CSIVolume
     */
    parameters?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CSIVolume
     */
    pluginID?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolume
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolume
     */
    providerVersion?: string;
    /**
     * 
     * @type {{ [key: string]: Allocation; }}
     * @memberof CSIVolume
     */
    readAllocs?: { [key: string]: Allocation; };
    /**
     * 
     * @type {Array<CSIVolumeCapability>}
     * @memberof CSIVolume
     */
    requestedCapabilities?: Array<CSIVolumeCapability>;
    /**
     * 
     * @type {number}
     * @memberof CSIVolume
     */
    requestedCapacityMax?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIVolume
     */
    requestedCapacityMin?: number;
    /**
     * 
     * @type {CSITopologyRequest}
     * @memberof CSIVolume
     */
    requestedTopologies?: CSITopologyRequest;
    /**
     * 
     * @type {Date}
     * @memberof CSIVolume
     */
    resourceExhausted?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof CSIVolume
     */
    schedulable?: boolean;
    /**
     * 
     * @type {CSISecrets}
     * @memberof CSIVolume
     */
    secrets?: CSISecrets;
    /**
     * 
     * @type {string}
     * @memberof CSIVolume
     */
    snapshotID?: string;
    /**
     * 
     * @type {Array<CSITopology>}
     * @memberof CSIVolume
     */
    topologies?: Array<CSITopology>;
    /**
     * 
     * @type {{ [key: string]: Allocation; }}
     * @memberof CSIVolume
     */
    writeAllocs?: { [key: string]: Allocation; };
}
/**
 * 
 * @export
 */
export type CSIVolumeAccessMode = string
/**
 * 
 * @export
 */
export type CSIVolumeAttachmentMode = string
/**
 * 
 * @export
 * @interface CSIVolumeCapability
 */
export interface CSIVolumeCapability {
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeCapability
     */
    accessMode?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeCapability
     */
    attachmentMode?: string;
}
/**
 * 
 * @export
 * @interface CSIVolumeCreateRequest
 */
export interface CSIVolumeCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeCreateRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeCreateRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeCreateRequest
     */
    secretID?: string;
    /**
     * 
     * @type {Array<CSIVolume>}
     * @memberof CSIVolumeCreateRequest
     */
    volumes?: Array<CSIVolume>;
}
/**
 * 
 * @export
 * @interface CSIVolumeExternalStub
 */
export interface CSIVolumeExternalStub {
    /**
     * 
     * @type {number}
     * @memberof CSIVolumeExternalStub
     */
    capacityBytes?: number;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeExternalStub
     */
    cloneID?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeExternalStub
     */
    externalID?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CSIVolumeExternalStub
     */
    isAbnormal?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CSIVolumeExternalStub
     */
    publishedExternalNodeIDs?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeExternalStub
     */
    snapshotID?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeExternalStub
     */
    status?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CSIVolumeExternalStub
     */
    volumeContext?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CSIVolumeListExternalResponse
 */
export interface CSIVolumeListExternalResponse {
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeListExternalResponse
     */
    nextToken?: string;
    /**
     * 
     * @type {Array<CSIVolumeExternalStub>}
     * @memberof CSIVolumeListExternalResponse
     */
    volumes?: Array<CSIVolumeExternalStub>;
}
/**
 * 
 * @export
 * @interface CSIVolumeListStub
 */
export interface CSIVolumeListStub {
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeListStub
     */
    accessMode?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeListStub
     */
    attachmentMode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CSIVolumeListStub
     */
    controllerRequired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CSIVolumeListStub
     */
    controllersExpected?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIVolumeListStub
     */
    controllersHealthy?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIVolumeListStub
     */
    createIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIVolumeListStub
     */
    currentReaders?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIVolumeListStub
     */
    currentWriters?: number;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeListStub
     */
    externalID?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeListStub
     */
    ID?: string;
    /**
     * 
     * @type {number}
     * @memberof CSIVolumeListStub
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeListStub
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeListStub
     */
    namespace?: string;
    /**
     * 
     * @type {number}
     * @memberof CSIVolumeListStub
     */
    nodesExpected?: number;
    /**
     * 
     * @type {number}
     * @memberof CSIVolumeListStub
     */
    nodesHealthy?: number;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeListStub
     */
    pluginID?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeListStub
     */
    provider?: string;
    /**
     * 
     * @type {Date}
     * @memberof CSIVolumeListStub
     */
    resourceExhausted?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof CSIVolumeListStub
     */
    schedulable?: boolean;
    /**
     * 
     * @type {Array<CSITopology>}
     * @memberof CSIVolumeListStub
     */
    topologies?: Array<CSITopology>;
}
/**
 * 
 * @export
 * @interface CSIVolumeRegisterRequest
 */
export interface CSIVolumeRegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeRegisterRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeRegisterRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof CSIVolumeRegisterRequest
     */
    secretID?: string;
    /**
     * 
     * @type {Array<CSIVolume>}
     * @memberof CSIVolumeRegisterRequest
     */
    volumes?: Array<CSIVolume>;
}
/**
 * 
 * @export
 * @interface ChangeScript
 */
export interface ChangeScript {
    /**
     * 
     * @type {Array<string>}
     * @memberof ChangeScript
     */
    args?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ChangeScript
     */
    command?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChangeScript
     */
    failOnError?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ChangeScript
     */
    timeout?: number;
}
/**
 * 
 * @export
 * @interface CheckRestart
 */
export interface CheckRestart {
    /**
     * 
     * @type {number}
     * @memberof CheckRestart
     */
    grace?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CheckRestart
     */
    ignoreWarnings?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CheckRestart
     */
    limit?: number;
}
/**
 * 
 * @export
 * @interface Constraint
 */
export interface Constraint {
    /**
     * 
     * @type {string}
     * @memberof Constraint
     */
    lTarget?: string;
    /**
     * 
     * @type {string}
     * @memberof Constraint
     */
    operand?: string;
    /**
     * 
     * @type {string}
     * @memberof Constraint
     */
    rTarget?: string;
}
/**
 * 
 * @export
 * @interface Consul
 */
export interface Consul {
    /**
     * 
     * @type {string}
     * @memberof Consul
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface ConsulConnect
 */
export interface ConsulConnect {
    /**
     * 
     * @type {ConsulGateway}
     * @memberof ConsulConnect
     */
    gateway?: ConsulGateway;
    /**
     * 
     * @type {boolean}
     * @memberof ConsulConnect
     */
    _native?: boolean;
    /**
     * 
     * @type {ConsulSidecarService}
     * @memberof ConsulConnect
     */
    sidecarService?: ConsulSidecarService;
    /**
     * 
     * @type {SidecarTask}
     * @memberof ConsulConnect
     */
    sidecarTask?: SidecarTask;
}
/**
 * 
 * @export
 * @interface ConsulExposeConfig
 */
export interface ConsulExposeConfig {
    /**
     * 
     * @type {Array<ConsulExposePath>}
     * @memberof ConsulExposeConfig
     */
    path?: Array<ConsulExposePath>;
}
/**
 * 
 * @export
 * @interface ConsulExposePath
 */
export interface ConsulExposePath {
    /**
     * 
     * @type {string}
     * @memberof ConsulExposePath
     */
    listenerPort?: string;
    /**
     * 
     * @type {number}
     * @memberof ConsulExposePath
     */
    localPathPort?: number;
    /**
     * 
     * @type {string}
     * @memberof ConsulExposePath
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsulExposePath
     */
    protocol?: string;
}
/**
 * 
 * @export
 * @interface ConsulGateway
 */
export interface ConsulGateway {
    /**
     * 
     * @type {ConsulIngressConfigEntry}
     * @memberof ConsulGateway
     */
    ingress?: ConsulIngressConfigEntry;
    /**
     * 
     * @type {any}
     * @memberof ConsulGateway
     */
    mesh?: any;
    /**
     * 
     * @type {ConsulGatewayProxy}
     * @memberof ConsulGateway
     */
    proxy?: ConsulGatewayProxy;
    /**
     * 
     * @type {ConsulTerminatingConfigEntry}
     * @memberof ConsulGateway
     */
    terminating?: ConsulTerminatingConfigEntry;
}
/**
 * 
 * @export
 * @interface ConsulGatewayBindAddress
 */
export interface ConsulGatewayBindAddress {
    /**
     * 
     * @type {string}
     * @memberof ConsulGatewayBindAddress
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsulGatewayBindAddress
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ConsulGatewayBindAddress
     */
    port?: number;
}
/**
 * 
 * @export
 * @interface ConsulGatewayProxy
 */
export interface ConsulGatewayProxy {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ConsulGatewayProxy
     */
    config?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof ConsulGatewayProxy
     */
    connectTimeout?: number;
    /**
     * 
     * @type {string}
     * @memberof ConsulGatewayProxy
     */
    envoyDNSDiscoveryType?: string;
    /**
     * 
     * @type {{ [key: string]: ConsulGatewayBindAddress; }}
     * @memberof ConsulGatewayProxy
     */
    envoyGatewayBindAddresses?: { [key: string]: ConsulGatewayBindAddress; };
    /**
     * 
     * @type {boolean}
     * @memberof ConsulGatewayProxy
     */
    envoyGatewayBindTaggedAddresses?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConsulGatewayProxy
     */
    envoyGatewayNoDefaultBind?: boolean;
}
/**
 * 
 * @export
 * @interface ConsulGatewayTLSConfig
 */
export interface ConsulGatewayTLSConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof ConsulGatewayTLSConfig
     */
    cipherSuites?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ConsulGatewayTLSConfig
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConsulGatewayTLSConfig
     */
    tLSMaxVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsulGatewayTLSConfig
     */
    tLSMinVersion?: string;
}
/**
 * 
 * @export
 * @interface ConsulIngressConfigEntry
 */
export interface ConsulIngressConfigEntry {
    /**
     * 
     * @type {Array<ConsulIngressListener>}
     * @memberof ConsulIngressConfigEntry
     */
    listeners?: Array<ConsulIngressListener>;
    /**
     * 
     * @type {ConsulGatewayTLSConfig}
     * @memberof ConsulIngressConfigEntry
     */
    TLS?: ConsulGatewayTLSConfig;
}
/**
 * 
 * @export
 * @interface ConsulIngressListener
 */
export interface ConsulIngressListener {
    /**
     * 
     * @type {number}
     * @memberof ConsulIngressListener
     */
    port?: number;
    /**
     * 
     * @type {string}
     * @memberof ConsulIngressListener
     */
    protocol?: string;
    /**
     * 
     * @type {Array<ConsulIngressService>}
     * @memberof ConsulIngressListener
     */
    services?: Array<ConsulIngressService>;
}
/**
 * 
 * @export
 * @interface ConsulIngressService
 */
export interface ConsulIngressService {
    /**
     * 
     * @type {Array<string>}
     * @memberof ConsulIngressService
     */
    hosts?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ConsulIngressService
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ConsulLinkedService
 */
export interface ConsulLinkedService {
    /**
     * 
     * @type {string}
     * @memberof ConsulLinkedService
     */
    cAFile?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsulLinkedService
     */
    certFile?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsulLinkedService
     */
    keyFile?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsulLinkedService
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsulLinkedService
     */
    SNI?: string;
}
/**
 * 
 * @export
 */
export type ConsulMeshConfigEntry = any
/**
 * 
 * @export
 * @interface ConsulMeshGateway
 */
export interface ConsulMeshGateway {
    /**
     * 
     * @type {string}
     * @memberof ConsulMeshGateway
     */
    mode?: string;
}
/**
 * 
 * @export
 * @interface ConsulProxy
 */
export interface ConsulProxy {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ConsulProxy
     */
    config?: { [key: string]: any; };
    /**
     * 
     * @type {ConsulExposeConfig}
     * @memberof ConsulProxy
     */
    exposeConfig?: ConsulExposeConfig;
    /**
     * 
     * @type {string}
     * @memberof ConsulProxy
     */
    localServiceAddress?: string;
    /**
     * 
     * @type {number}
     * @memberof ConsulProxy
     */
    localServicePort?: number;
    /**
     * 
     * @type {Array<ConsulUpstream>}
     * @memberof ConsulProxy
     */
    upstreams?: Array<ConsulUpstream>;
}
/**
 * 
 * @export
 * @interface ConsulSidecarService
 */
export interface ConsulSidecarService {
    /**
     * 
     * @type {boolean}
     * @memberof ConsulSidecarService
     */
    disableDefaultTCPCheck?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConsulSidecarService
     */
    port?: string;
    /**
     * 
     * @type {ConsulProxy}
     * @memberof ConsulSidecarService
     */
    proxy?: ConsulProxy;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConsulSidecarService
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface ConsulTerminatingConfigEntry
 */
export interface ConsulTerminatingConfigEntry {
    /**
     * 
     * @type {Array<ConsulLinkedService>}
     * @memberof ConsulTerminatingConfigEntry
     */
    services?: Array<ConsulLinkedService>;
}
/**
 * 
 * @export
 * @interface ConsulUpstream
 */
export interface ConsulUpstream {
    /**
     * 
     * @type {string}
     * @memberof ConsulUpstream
     */
    datacenter?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsulUpstream
     */
    destinationName?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsulUpstream
     */
    destinationNamespace?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsulUpstream
     */
    localBindAddress?: string;
    /**
     * 
     * @type {number}
     * @memberof ConsulUpstream
     */
    localBindPort?: number;
    /**
     * 
     * @type {ConsulMeshGateway}
     * @memberof ConsulUpstream
     */
    meshGateway?: ConsulMeshGateway;
}
/**
 * 
 * @export
 */
export type Context = string
/**
 * 
 * @export
 * @interface DNSConfig
 */
export interface DNSConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof DNSConfig
     */
    options?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DNSConfig
     */
    searches?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DNSConfig
     */
    servers?: Array<string>;
}
/**
 * 
 * @export
 * @interface Deployment
 */
export interface Deployment {
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    createIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    ID?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Deployment
     */
    isMultiregion?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    jobCreateIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    jobID?: string;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    jobModifyIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    jobSpecModifyIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    jobVersion?: number;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    statusDescription?: string;
    /**
     * 
     * @type {{ [key: string]: DeploymentState; }}
     * @memberof Deployment
     */
    taskGroups?: { [key: string]: DeploymentState; };
}
/**
 * 
 * @export
 * @interface DeploymentAllocHealthRequest
 */
export interface DeploymentAllocHealthRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentAllocHealthRequest
     */
    deploymentID?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentAllocHealthRequest
     */
    healthyAllocationIDs?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeploymentAllocHealthRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentAllocHealthRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentAllocHealthRequest
     */
    secretID?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentAllocHealthRequest
     */
    unhealthyAllocationIDs?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeploymentPauseRequest
 */
export interface DeploymentPauseRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentPauseRequest
     */
    deploymentID?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentPauseRequest
     */
    namespace?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeploymentPauseRequest
     */
    pause?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeploymentPauseRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentPauseRequest
     */
    secretID?: string;
}
/**
 * 
 * @export
 * @interface DeploymentPromoteRequest
 */
export interface DeploymentPromoteRequest {
    /**
     * 
     * @type {boolean}
     * @memberof DeploymentPromoteRequest
     */
    all?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeploymentPromoteRequest
     */
    deploymentID?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentPromoteRequest
     */
    groups?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeploymentPromoteRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentPromoteRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentPromoteRequest
     */
    secretID?: string;
}
/**
 * 
 * @export
 * @interface DeploymentState
 */
export interface DeploymentState {
    /**
     * 
     * @type {boolean}
     * @memberof DeploymentState
     */
    autoRevert?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeploymentState
     */
    desiredCanaries?: number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentState
     */
    desiredTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentState
     */
    healthyAllocs?: number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentState
     */
    placedAllocs?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentState
     */
    placedCanaries?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DeploymentState
     */
    progressDeadline?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DeploymentState
     */
    promoted?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof DeploymentState
     */
    requireProgressBy?: Date;
    /**
     * 
     * @type {number}
     * @memberof DeploymentState
     */
    unhealthyAllocs?: number;
}
/**
 * 
 * @export
 * @interface DeploymentUnblockRequest
 */
export interface DeploymentUnblockRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentUnblockRequest
     */
    deploymentID?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentUnblockRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentUnblockRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentUnblockRequest
     */
    secretID?: string;
}
/**
 * 
 * @export
 * @interface DeploymentUpdateResponse
 */
export interface DeploymentUpdateResponse {
    /**
     * 
     * @type {number}
     * @memberof DeploymentUpdateResponse
     */
    deploymentModifyIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentUpdateResponse
     */
    evalCreateIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof DeploymentUpdateResponse
     */
    evalID?: string;
    /**
     * 
     * @type {number}
     * @memberof DeploymentUpdateResponse
     */
    lastIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentUpdateResponse
     */
    requestTime?: number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentUpdateResponse
     */
    revertedJobVersion?: number;
}
/**
 * 
 * @export
 * @interface DesiredTransition
 */
export interface DesiredTransition {
    /**
     * 
     * @type {boolean}
     * @memberof DesiredTransition
     */
    migrate?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DesiredTransition
     */
    reschedule?: boolean;
}
/**
 * 
 * @export
 * @interface DesiredUpdates
 */
export interface DesiredUpdates {
    /**
     * 
     * @type {number}
     * @memberof DesiredUpdates
     */
    canary?: number;
    /**
     * 
     * @type {number}
     * @memberof DesiredUpdates
     */
    destructiveUpdate?: number;
    /**
     * 
     * @type {number}
     * @memberof DesiredUpdates
     */
    ignore?: number;
    /**
     * 
     * @type {number}
     * @memberof DesiredUpdates
     */
    inPlaceUpdate?: number;
    /**
     * 
     * @type {number}
     * @memberof DesiredUpdates
     */
    migrate?: number;
    /**
     * 
     * @type {number}
     * @memberof DesiredUpdates
     */
    place?: number;
    /**
     * 
     * @type {number}
     * @memberof DesiredUpdates
     */
    preemptions?: number;
    /**
     * 
     * @type {number}
     * @memberof DesiredUpdates
     */
    stop?: number;
}
/**
 * 
 * @export
 * @interface DispatchPayloadConfig
 */
export interface DispatchPayloadConfig {
    /**
     * 
     * @type {string}
     * @memberof DispatchPayloadConfig
     */
    file?: string;
}
/**
 * 
 * @export
 * @interface DrainMetadata
 */
export interface DrainMetadata {
    /**
     * 
     * @type {string}
     * @memberof DrainMetadata
     */
    accessorID?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DrainMetadata
     */
    meta?: { [key: string]: string; };
    /**
     * 
     * @type {Date}
     * @memberof DrainMetadata
     */
    startedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof DrainMetadata
     */
    status?: string;
    /**
     * 
     * @type {Date}
     * @memberof DrainMetadata
     */
    updatedAt?: Date;
}
/**
 * 
 * @export
 * @interface DrainSpec
 */
export interface DrainSpec {
    /**
     * 
     * @type {number}
     * @memberof DrainSpec
     */
    deadline?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DrainSpec
     */
    ignoreSystemJobs?: boolean;
}
/**
 * 
 * @export
 */
export type DrainStatus = string
/**
 * 
 * @export
 * @interface DrainStrategy
 */
export interface DrainStrategy {
    /**
     * 
     * @type {number}
     * @memberof DrainStrategy
     */
    deadline?: number;
    /**
     * 
     * @type {Date}
     * @memberof DrainStrategy
     */
    forceDeadline?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof DrainStrategy
     */
    ignoreSystemJobs?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof DrainStrategy
     */
    startedAt?: Date;
}
/**
 * 
 * @export
 * @interface DriverInfo
 */
export interface DriverInfo {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DriverInfo
     */
    attributes?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof DriverInfo
     */
    detected?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DriverInfo
     */
    healthDescription?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DriverInfo
     */
    healthy?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof DriverInfo
     */
    updateTime?: Date;
}
/**
 * 
 * @export
 */
export type Duration = number
/**
 * 
 * @export
 * @interface EphemeralDisk
 */
export interface EphemeralDisk {
    /**
     * 
     * @type {boolean}
     * @memberof EphemeralDisk
     */
    migrate?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EphemeralDisk
     */
    sizeMB?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EphemeralDisk
     */
    sticky?: boolean;
}
/**
 * 
 * @export
 * @interface EvalOptions
 */
export interface EvalOptions {
    /**
     * 
     * @type {boolean}
     * @memberof EvalOptions
     */
    forceReschedule?: boolean;
}
/**
 * 
 * @export
 * @interface Evaluation
 */
export interface Evaluation {
    /**
     * 
     * @type {boolean}
     * @memberof Evaluation
     */
    annotatePlan?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    blockedEval?: string;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof Evaluation
     */
    classEligibility?: { [key: string]: boolean; };
    /**
     * 
     * @type {number}
     * @memberof Evaluation
     */
    createIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof Evaluation
     */
    createTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    deploymentID?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Evaluation
     */
    escapedComputedClass?: boolean;
    /**
     * 
     * @type {{ [key: string]: AllocationMetric; }}
     * @memberof Evaluation
     */
    failedTGAllocs?: { [key: string]: AllocationMetric; };
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    ID?: string;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    jobID?: string;
    /**
     * 
     * @type {number}
     * @memberof Evaluation
     */
    jobModifyIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof Evaluation
     */
    modifyIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof Evaluation
     */
    modifyTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    nextEval?: string;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    nodeID?: string;
    /**
     * 
     * @type {number}
     * @memberof Evaluation
     */
    nodeModifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    previousEval?: string;
    /**
     * 
     * @type {number}
     * @memberof Evaluation
     */
    priority?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof Evaluation
     */
    queuedAllocations?: { [key: string]: number; };
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    quotaLimitReached?: string;
    /**
     * 
     * @type {Array<EvaluationStub>}
     * @memberof Evaluation
     */
    relatedEvals?: Array<EvaluationStub>;
    /**
     * 
     * @type {number}
     * @memberof Evaluation
     */
    snapshotIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    statusDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    triggeredBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof Evaluation
     */
    wait?: number;
    /**
     * 
     * @type {Date}
     * @memberof Evaluation
     */
    waitUntil?: Date;
}
/**
 * 
 * @export
 * @interface EvaluationStub
 */
export interface EvaluationStub {
    /**
     * 
     * @type {string}
     * @memberof EvaluationStub
     */
    blockedEval?: string;
    /**
     * 
     * @type {number}
     * @memberof EvaluationStub
     */
    createIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof EvaluationStub
     */
    createTime?: number;
    /**
     * 
     * @type {string}
     * @memberof EvaluationStub
     */
    deploymentID?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluationStub
     */
    ID?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluationStub
     */
    jobID?: string;
    /**
     * 
     * @type {number}
     * @memberof EvaluationStub
     */
    modifyIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof EvaluationStub
     */
    modifyTime?: number;
    /**
     * 
     * @type {string}
     * @memberof EvaluationStub
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluationStub
     */
    nextEval?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluationStub
     */
    nodeID?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluationStub
     */
    previousEval?: string;
    /**
     * 
     * @type {number}
     * @memberof EvaluationStub
     */
    priority?: number;
    /**
     * 
     * @type {string}
     * @memberof EvaluationStub
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluationStub
     */
    statusDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluationStub
     */
    triggeredBy?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluationStub
     */
    type?: string;
    /**
     * 
     * @type {Date}
     * @memberof EvaluationStub
     */
    waitUntil?: Date;
}
/**
 * 
 * @export
 * @interface FieldDiff
 */
export interface FieldDiff {
    /**
     * 
     * @type {Array<string>}
     * @memberof FieldDiff
     */
    annotations?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FieldDiff
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldDiff
     */
    _new?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldDiff
     */
    old?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldDiff
     */
    type?: string;
}
/**
 * 
 * @export
 */
export type Float32 = number
/**
 * 
 * @export
 */
export type Float64 = number
/**
 * 
 * @export
 * @interface FuzzyMatch
 */
export interface FuzzyMatch {
    /**
     * 
     * @type {string}
     * @memberof FuzzyMatch
     */
    ID?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FuzzyMatch
     */
    scope?: Array<string>;
}
/**
 * 
 * @export
 * @interface FuzzySearchRequest
 */
export interface FuzzySearchRequest {
    /**
     * 
     * @type {boolean}
     * @memberof FuzzySearchRequest
     */
    allowStale?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FuzzySearchRequest
     */
    authToken?: string;
    /**
     * 
     * @type {string}
     * @memberof FuzzySearchRequest
     */
    context?: string;
    /**
     * 
     * @type {string}
     * @memberof FuzzySearchRequest
     */
    filter?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FuzzySearchRequest
     */
    headers?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof FuzzySearchRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof FuzzySearchRequest
     */
    nextToken?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FuzzySearchRequest
     */
    params?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof FuzzySearchRequest
     */
    perPage?: number;
    /**
     * 
     * @type {string}
     * @memberof FuzzySearchRequest
     */
    prefix?: string;
    /**
     * 
     * @type {string}
     * @memberof FuzzySearchRequest
     */
    region?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FuzzySearchRequest
     */
    reverse?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FuzzySearchRequest
     */
    text?: string;
    /**
     * 
     * @type {number}
     * @memberof FuzzySearchRequest
     */
    waitIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof FuzzySearchRequest
     */
    waitTime?: number;
}
/**
 * 
 * @export
 * @interface FuzzySearchResponse
 */
export interface FuzzySearchResponse {
    /**
     * 
     * @type {boolean}
     * @memberof FuzzySearchResponse
     */
    knownLeader?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FuzzySearchResponse
     */
    lastContact?: number;
    /**
     * 
     * @type {number}
     * @memberof FuzzySearchResponse
     */
    lastIndex?: number;
    /**
     * 
     * @type {{ [key: string]: Array<FuzzyMatch>; }}
     * @memberof FuzzySearchResponse
     */
    matches?: { [key: string]: Array<FuzzyMatch>; };
    /**
     * 
     * @type {string}
     * @memberof FuzzySearchResponse
     */
    nextToken?: string;
    /**
     * 
     * @type {number}
     * @memberof FuzzySearchResponse
     */
    requestTime?: number;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof FuzzySearchResponse
     */
    truncations?: { [key: string]: boolean; };
}
/**
 * 
 * @export
 * @interface GaugeValue
 */
export interface GaugeValue {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GaugeValue
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GaugeValue
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof GaugeValue
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface HostNetworkInfo
 */
export interface HostNetworkInfo {
    /**
     * 
     * @type {string}
     * @memberof HostNetworkInfo
     */
    CIDR?: string;
    /**
     * 
     * @type {string}
     * @memberof HostNetworkInfo
     */
    _interface?: string;
    /**
     * 
     * @type {string}
     * @memberof HostNetworkInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof HostNetworkInfo
     */
    reservedPorts?: string;
}
/**
 * 
 * @export
 * @interface HostVolumeInfo
 */
export interface HostVolumeInfo {
    /**
     * 
     * @type {string}
     * @memberof HostVolumeInfo
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HostVolumeInfo
     */
    readOnly?: boolean;
}
/**
 * 
 * @export
 */
export type Int32 = number
/**
 * 
 * @export
 */
export type Int64 = number
/**
 * 
 * @export
 */
export type Int8 = number
/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {Array<Affinity>}
     * @memberof Job
     */
    affinities?: Array<Affinity>;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    allAtOnce?: boolean;
    /**
     * 
     * @type {Array<Constraint>}
     * @memberof Job
     */
    constraints?: Array<Constraint>;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    consulNamespace?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    consulToken?: string;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    createIndex?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Job
     */
    datacenters?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    dispatchIdempotencyToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    dispatched?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    ID?: string;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    jobModifyIndex?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Job
     */
    meta?: { [key: string]: string; };
    /**
     * 
     * @type {MigrateStrategy}
     * @memberof Job
     */
    migrate?: MigrateStrategy;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    modifyIndex?: number;
    /**
     * 
     * @type {Multiregion}
     * @memberof Job
     */
    multiregion?: Multiregion;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    nomadTokenID?: string;
    /**
     * 
     * @type {ParameterizedJobConfig}
     * @memberof Job
     */
    parameterizedJob?: ParameterizedJobConfig;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    parentID?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    payload?: string;
    /**
     * 
     * @type {PeriodicConfig}
     * @memberof Job
     */
    periodic?: PeriodicConfig;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    priority?: number;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    region?: string;
    /**
     * 
     * @type {ReschedulePolicy}
     * @memberof Job
     */
    reschedule?: ReschedulePolicy;
    /**
     * 
     * @type {Array<Spread>}
     * @memberof Job
     */
    spreads?: Array<Spread>;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    stable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    statusDescription?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    stop?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    submitTime?: number;
    /**
     * 
     * @type {Array<TaskGroup>}
     * @memberof Job
     */
    taskGroups?: Array<TaskGroup>;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    type?: string;
    /**
     * 
     * @type {UpdateStrategy}
     * @memberof Job
     */
    update?: UpdateStrategy;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    vaultNamespace?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    vaultToken?: string;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    version?: number;
}
/**
 * 
 * @export
 * @interface JobACL
 */
export interface JobACL {
    /**
     * 
     * @type {string}
     * @memberof JobACL
     */
    group?: string;
    /**
     * 
     * @type {string}
     * @memberof JobACL
     */
    jobID?: string;
    /**
     * 
     * @type {string}
     * @memberof JobACL
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof JobACL
     */
    task?: string;
}
/**
 * 
 * @export
 * @interface JobChildrenSummary
 */
export interface JobChildrenSummary {
    /**
     * 
     * @type {number}
     * @memberof JobChildrenSummary
     */
    dead?: number;
    /**
     * 
     * @type {number}
     * @memberof JobChildrenSummary
     */
    pending?: number;
    /**
     * 
     * @type {number}
     * @memberof JobChildrenSummary
     */
    running?: number;
}
/**
 * 
 * @export
 * @interface JobDeregisterResponse
 */
export interface JobDeregisterResponse {
    /**
     * 
     * @type {number}
     * @memberof JobDeregisterResponse
     */
    evalCreateIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof JobDeregisterResponse
     */
    evalID?: string;
    /**
     * 
     * @type {number}
     * @memberof JobDeregisterResponse
     */
    jobModifyIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof JobDeregisterResponse
     */
    knownLeader?: boolean;
    /**
     * 
     * @type {number}
     * @memberof JobDeregisterResponse
     */
    lastContact?: number;
    /**
     * 
     * @type {number}
     * @memberof JobDeregisterResponse
     */
    lastIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof JobDeregisterResponse
     */
    nextToken?: string;
    /**
     * 
     * @type {number}
     * @memberof JobDeregisterResponse
     */
    requestTime?: number;
}
/**
 * 
 * @export
 * @interface JobDiff
 */
export interface JobDiff {
    /**
     * 
     * @type {Array<FieldDiff>}
     * @memberof JobDiff
     */
    fields?: Array<FieldDiff>;
    /**
     * 
     * @type {string}
     * @memberof JobDiff
     */
    ID?: string;
    /**
     * 
     * @type {Array<ObjectDiff>}
     * @memberof JobDiff
     */
    objects?: Array<ObjectDiff>;
    /**
     * 
     * @type {Array<TaskGroupDiff>}
     * @memberof JobDiff
     */
    taskGroups?: Array<TaskGroupDiff>;
    /**
     * 
     * @type {string}
     * @memberof JobDiff
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface JobDispatchRequest
 */
export interface JobDispatchRequest {
    /**
     * 
     * @type {string}
     * @memberof JobDispatchRequest
     */
    jobID?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof JobDispatchRequest
     */
    meta?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof JobDispatchRequest
     */
    payload?: string;
}
/**
 * 
 * @export
 * @interface JobDispatchResponse
 */
export interface JobDispatchResponse {
    /**
     * 
     * @type {string}
     * @memberof JobDispatchResponse
     */
    dispatchedJobID?: string;
    /**
     * 
     * @type {number}
     * @memberof JobDispatchResponse
     */
    evalCreateIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof JobDispatchResponse
     */
    evalID?: string;
    /**
     * 
     * @type {number}
     * @memberof JobDispatchResponse
     */
    jobCreateIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof JobDispatchResponse
     */
    lastIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof JobDispatchResponse
     */
    requestTime?: number;
}
/**
 * 
 * @export
 * @interface JobEvaluateRequest
 */
export interface JobEvaluateRequest {
    /**
     * 
     * @type {EvalOptions}
     * @memberof JobEvaluateRequest
     */
    evalOptions?: EvalOptions;
    /**
     * 
     * @type {string}
     * @memberof JobEvaluateRequest
     */
    jobID?: string;
    /**
     * 
     * @type {string}
     * @memberof JobEvaluateRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof JobEvaluateRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof JobEvaluateRequest
     */
    secretID?: string;
}
/**
 * 
 * @export
 * @interface JobListStub
 */
export interface JobListStub {
    /**
     * 
     * @type {number}
     * @memberof JobListStub
     */
    createIndex?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof JobListStub
     */
    datacenters?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof JobListStub
     */
    ID?: string;
    /**
     * 
     * @type {number}
     * @memberof JobListStub
     */
    jobModifyIndex?: number;
    /**
     * 
     * @type {JobSummary}
     * @memberof JobListStub
     */
    jobSummary?: JobSummary;
    /**
     * 
     * @type {number}
     * @memberof JobListStub
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof JobListStub
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof JobListStub
     */
    namespace?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JobListStub
     */
    parameterizedJob?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JobListStub
     */
    parentID?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JobListStub
     */
    periodic?: boolean;
    /**
     * 
     * @type {number}
     * @memberof JobListStub
     */
    priority?: number;
    /**
     * 
     * @type {string}
     * @memberof JobListStub
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof JobListStub
     */
    statusDescription?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JobListStub
     */
    stop?: boolean;
    /**
     * 
     * @type {number}
     * @memberof JobListStub
     */
    submitTime?: number;
    /**
     * 
     * @type {string}
     * @memberof JobListStub
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface JobPlanRequest
 */
export interface JobPlanRequest {
    /**
     * 
     * @type {boolean}
     * @memberof JobPlanRequest
     */
    diff?: boolean;
    /**
     * 
     * @type {Job}
     * @memberof JobPlanRequest
     */
    job?: Job;
    /**
     * 
     * @type {string}
     * @memberof JobPlanRequest
     */
    namespace?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JobPlanRequest
     */
    policyOverride?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JobPlanRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof JobPlanRequest
     */
    secretID?: string;
}
/**
 * 
 * @export
 * @interface JobPlanResponse
 */
export interface JobPlanResponse {
    /**
     * 
     * @type {PlanAnnotations}
     * @memberof JobPlanResponse
     */
    annotations?: PlanAnnotations;
    /**
     * 
     * @type {Array<Evaluation>}
     * @memberof JobPlanResponse
     */
    createdEvals?: Array<Evaluation>;
    /**
     * 
     * @type {JobDiff}
     * @memberof JobPlanResponse
     */
    diff?: JobDiff;
    /**
     * 
     * @type {{ [key: string]: AllocationMetric; }}
     * @memberof JobPlanResponse
     */
    failedTGAllocs?: { [key: string]: AllocationMetric; };
    /**
     * 
     * @type {number}
     * @memberof JobPlanResponse
     */
    jobModifyIndex?: number;
    /**
     * 
     * @type {Date}
     * @memberof JobPlanResponse
     */
    nextPeriodicLaunch?: Date;
    /**
     * 
     * @type {string}
     * @memberof JobPlanResponse
     */
    warnings?: string;
}
/**
 * 
 * @export
 * @interface JobRegisterRequest
 */
export interface JobRegisterRequest {
    /**
     * 
     * @type {boolean}
     * @memberof JobRegisterRequest
     */
    enforceIndex?: boolean;
    /**
     * 
     * @type {number}
     * @memberof JobRegisterRequest
     */
    evalPriority?: number;
    /**
     * 
     * @type {Job}
     * @memberof JobRegisterRequest
     */
    job?: Job;
    /**
     * 
     * @type {number}
     * @memberof JobRegisterRequest
     */
    jobModifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof JobRegisterRequest
     */
    namespace?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JobRegisterRequest
     */
    policyOverride?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JobRegisterRequest
     */
    preserveCounts?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JobRegisterRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof JobRegisterRequest
     */
    secretID?: string;
}
/**
 * 
 * @export
 * @interface JobRegisterResponse
 */
export interface JobRegisterResponse {
    /**
     * 
     * @type {number}
     * @memberof JobRegisterResponse
     */
    evalCreateIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof JobRegisterResponse
     */
    evalID?: string;
    /**
     * 
     * @type {number}
     * @memberof JobRegisterResponse
     */
    jobModifyIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof JobRegisterResponse
     */
    knownLeader?: boolean;
    /**
     * 
     * @type {number}
     * @memberof JobRegisterResponse
     */
    lastContact?: number;
    /**
     * 
     * @type {number}
     * @memberof JobRegisterResponse
     */
    lastIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof JobRegisterResponse
     */
    nextToken?: string;
    /**
     * 
     * @type {number}
     * @memberof JobRegisterResponse
     */
    requestTime?: number;
    /**
     * 
     * @type {string}
     * @memberof JobRegisterResponse
     */
    warnings?: string;
}
/**
 * 
 * @export
 * @interface JobRevertRequest
 */
export interface JobRevertRequest {
    /**
     * 
     * @type {string}
     * @memberof JobRevertRequest
     */
    consulToken?: string;
    /**
     * 
     * @type {number}
     * @memberof JobRevertRequest
     */
    enforcePriorVersion?: number;
    /**
     * 
     * @type {string}
     * @memberof JobRevertRequest
     */
    jobID?: string;
    /**
     * 
     * @type {number}
     * @memberof JobRevertRequest
     */
    jobVersion?: number;
    /**
     * 
     * @type {string}
     * @memberof JobRevertRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof JobRevertRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof JobRevertRequest
     */
    secretID?: string;
    /**
     * 
     * @type {string}
     * @memberof JobRevertRequest
     */
    vaultToken?: string;
}
/**
 * 
 * @export
 * @interface JobScaleStatusResponse
 */
export interface JobScaleStatusResponse {
    /**
     * 
     * @type {number}
     * @memberof JobScaleStatusResponse
     */
    jobCreateIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof JobScaleStatusResponse
     */
    jobID?: string;
    /**
     * 
     * @type {number}
     * @memberof JobScaleStatusResponse
     */
    jobModifyIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof JobScaleStatusResponse
     */
    jobStopped?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JobScaleStatusResponse
     */
    namespace?: string;
    /**
     * 
     * @type {{ [key: string]: TaskGroupScaleStatus; }}
     * @memberof JobScaleStatusResponse
     */
    taskGroups?: { [key: string]: TaskGroupScaleStatus; };
}
/**
 * 
 * @export
 * @interface JobStabilityRequest
 */
export interface JobStabilityRequest {
    /**
     * 
     * @type {string}
     * @memberof JobStabilityRequest
     */
    jobID?: string;
    /**
     * 
     * @type {number}
     * @memberof JobStabilityRequest
     */
    jobVersion?: number;
    /**
     * 
     * @type {string}
     * @memberof JobStabilityRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof JobStabilityRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof JobStabilityRequest
     */
    secretID?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JobStabilityRequest
     */
    stable?: boolean;
}
/**
 * 
 * @export
 * @interface JobStabilityResponse
 */
export interface JobStabilityResponse {
    /**
     * 
     * @type {number}
     * @memberof JobStabilityResponse
     */
    index?: number;
}
/**
 * 
 * @export
 * @interface JobSummary
 */
export interface JobSummary {
    /**
     * 
     * @type {JobChildrenSummary}
     * @memberof JobSummary
     */
    children?: JobChildrenSummary;
    /**
     * 
     * @type {number}
     * @memberof JobSummary
     */
    createIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof JobSummary
     */
    jobID?: string;
    /**
     * 
     * @type {number}
     * @memberof JobSummary
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof JobSummary
     */
    namespace?: string;
    /**
     * 
     * @type {{ [key: string]: TaskGroupSummary; }}
     * @memberof JobSummary
     */
    summary?: { [key: string]: TaskGroupSummary; };
}
/**
 * 
 * @export
 * @interface JobValidateRequest
 */
export interface JobValidateRequest {
    /**
     * 
     * @type {Job}
     * @memberof JobValidateRequest
     */
    job?: Job;
    /**
     * 
     * @type {string}
     * @memberof JobValidateRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof JobValidateRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof JobValidateRequest
     */
    secretID?: string;
}
/**
 * 
 * @export
 * @interface JobValidateResponse
 */
export interface JobValidateResponse {
    /**
     * 
     * @type {boolean}
     * @memberof JobValidateResponse
     */
    driverConfigValidated?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JobValidateResponse
     */
    error?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof JobValidateResponse
     */
    validationErrors?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof JobValidateResponse
     */
    warnings?: string;
}
/**
 * 
 * @export
 * @interface JobVersionsResponse
 */
export interface JobVersionsResponse {
    /**
     * 
     * @type {Array<JobDiff>}
     * @memberof JobVersionsResponse
     */
    diffs?: Array<JobDiff>;
    /**
     * 
     * @type {boolean}
     * @memberof JobVersionsResponse
     */
    knownLeader?: boolean;
    /**
     * 
     * @type {number}
     * @memberof JobVersionsResponse
     */
    lastContact?: number;
    /**
     * 
     * @type {number}
     * @memberof JobVersionsResponse
     */
    lastIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof JobVersionsResponse
     */
    nextToken?: string;
    /**
     * 
     * @type {number}
     * @memberof JobVersionsResponse
     */
    requestTime?: number;
    /**
     * 
     * @type {Array<Job>}
     * @memberof JobVersionsResponse
     */
    versions?: Array<Job>;
}
/**
 * 
 * @export
 * @interface JobsParseRequest
 */
export interface JobsParseRequest {
    /**
     * 
     * @type {boolean}
     * @memberof JobsParseRequest
     */
    canonicalize?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JobsParseRequest
     */
    jobHCL?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JobsParseRequest
     */
    hclv1?: boolean;
}
/**
 * 
 * @export
 * @interface LogConfig
 */
export interface LogConfig {
    /**
     * 
     * @type {number}
     * @memberof LogConfig
     */
    maxFileSizeMB?: number;
    /**
     * 
     * @type {number}
     * @memberof LogConfig
     */
    maxFiles?: number;
}
/**
 * 
 * @export
 * @interface MetricsSummary
 */
export interface MetricsSummary {
    /**
     * 
     * @type {Array<SampledValue>}
     * @memberof MetricsSummary
     */
    counters?: Array<SampledValue>;
    /**
     * 
     * @type {Array<GaugeValue>}
     * @memberof MetricsSummary
     */
    gauges?: Array<GaugeValue>;
    /**
     * 
     * @type {Array<PointValue>}
     * @memberof MetricsSummary
     */
    points?: Array<PointValue>;
    /**
     * 
     * @type {Array<SampledValue>}
     * @memberof MetricsSummary
     */
    samples?: Array<SampledValue>;
    /**
     * 
     * @type {string}
     * @memberof MetricsSummary
     */
    timestamp?: string;
}
/**
 * 
 * @export
 * @interface MigrateStrategy
 */
export interface MigrateStrategy {
    /**
     * 
     * @type {string}
     * @memberof MigrateStrategy
     */
    healthCheck?: string;
    /**
     * 
     * @type {number}
     * @memberof MigrateStrategy
     */
    healthyDeadline?: number;
    /**
     * 
     * @type {number}
     * @memberof MigrateStrategy
     */
    maxParallel?: number;
    /**
     * 
     * @type {number}
     * @memberof MigrateStrategy
     */
    minHealthyTime?: number;
}
/**
 * 
 * @export
 */
export type ModelInt = number
/**
 * 
 * @export
 * @interface Multiregion
 */
export interface Multiregion {
    /**
     * 
     * @type {Array<MultiregionRegion>}
     * @memberof Multiregion
     */
    regions?: Array<MultiregionRegion>;
    /**
     * 
     * @type {MultiregionStrategy}
     * @memberof Multiregion
     */
    strategy?: MultiregionStrategy;
}
/**
 * 
 * @export
 * @interface MultiregionRegion
 */
export interface MultiregionRegion {
    /**
     * 
     * @type {number}
     * @memberof MultiregionRegion
     */
    count?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof MultiregionRegion
     */
    datacenters?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MultiregionRegion
     */
    meta?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof MultiregionRegion
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface MultiregionStrategy
 */
export interface MultiregionStrategy {
    /**
     * 
     * @type {number}
     * @memberof MultiregionStrategy
     */
    maxParallel?: number;
    /**
     * 
     * @type {string}
     * @memberof MultiregionStrategy
     */
    onFailure?: string;
}
/**
 * 
 * @export
 * @interface Namespace
 */
export interface Namespace {
    /**
     * 
     * @type {NamespaceCapabilities}
     * @memberof Namespace
     */
    capabilities?: NamespaceCapabilities;
    /**
     * 
     * @type {number}
     * @memberof Namespace
     */
    createIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof Namespace
     */
    description?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Namespace
     */
    meta?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof Namespace
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof Namespace
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Namespace
     */
    quota?: string;
}
/**
 * 
 * @export
 * @interface NamespaceCapabilities
 */
export interface NamespaceCapabilities {
    /**
     * 
     * @type {Array<string>}
     * @memberof NamespaceCapabilities
     */
    disabledTaskDrivers?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NamespaceCapabilities
     */
    enabledTaskDrivers?: Array<string>;
}
/**
 * 
 * @export
 * @interface NetworkResource
 */
export interface NetworkResource {
    /**
     * 
     * @type {string}
     * @memberof NetworkResource
     */
    CIDR?: string;
    /**
     * 
     * @type {DNSConfig}
     * @memberof NetworkResource
     */
    DNS?: DNSConfig;
    /**
     * 
     * @type {string}
     * @memberof NetworkResource
     */
    device?: string;
    /**
     * 
     * @type {Array<Port>}
     * @memberof NetworkResource
     */
    dynamicPorts?: Array<Port>;
    /**
     * 
     * @type {string}
     * @memberof NetworkResource
     */
    hostname?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResource
     */
    IP?: string;
    /**
     * 
     * @type {number}
     * @memberof NetworkResource
     */
    mBits?: number;
    /**
     * 
     * @type {string}
     * @memberof NetworkResource
     */
    mode?: string;
    /**
     * 
     * @type {Array<Port>}
     * @memberof NetworkResource
     */
    reservedPorts?: Array<Port>;
}
/**
 * 
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Node
     */
    attributes?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: CSIInfo; }}
     * @memberof Node
     */
    cSIControllerPlugins?: { [key: string]: CSIInfo; };
    /**
     * 
     * @type {{ [key: string]: CSIInfo; }}
     * @memberof Node
     */
    cSINodePlugins?: { [key: string]: CSIInfo; };
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    cgroupParent?: string;
    /**
     * 
     * @type {number}
     * @memberof Node
     */
    createIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    datacenter?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Node
     */
    drain?: boolean;
    /**
     * 
     * @type {DrainStrategy}
     * @memberof Node
     */
    drainStrategy?: DrainStrategy;
    /**
     * 
     * @type {{ [key: string]: DriverInfo; }}
     * @memberof Node
     */
    drivers?: { [key: string]: DriverInfo; };
    /**
     * 
     * @type {Array<NodeEvent>}
     * @memberof Node
     */
    events?: Array<NodeEvent>;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    hTTPAddr?: string;
    /**
     * 
     * @type {{ [key: string]: HostNetworkInfo; }}
     * @memberof Node
     */
    hostNetworks?: { [key: string]: HostNetworkInfo; };
    /**
     * 
     * @type {{ [key: string]: HostVolumeInfo; }}
     * @memberof Node
     */
    hostVolumes?: { [key: string]: HostVolumeInfo; };
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    ID?: string;
    /**
     * 
     * @type {DrainMetadata}
     * @memberof Node
     */
    lastDrain?: DrainMetadata;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Node
     */
    links?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Node
     */
    meta?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof Node
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    nodeClass?: string;
    /**
     * 
     * @type {NodeResources}
     * @memberof Node
     */
    nodeResources?: NodeResources;
    /**
     * 
     * @type {Resources}
     * @memberof Node
     */
    reserved?: Resources;
    /**
     * 
     * @type {NodeReservedResources}
     * @memberof Node
     */
    reservedResources?: NodeReservedResources;
    /**
     * 
     * @type {Resources}
     * @memberof Node
     */
    resources?: Resources;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    schedulingEligibility?: string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    statusDescription?: string;
    /**
     * 
     * @type {number}
     * @memberof Node
     */
    statusUpdatedAt?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Node
     */
    tLSEnabled?: boolean;
}
/**
 * 
 * @export
 * @interface NodeCpuResources
 */
export interface NodeCpuResources {
    /**
     * 
     * @type {number}
     * @memberof NodeCpuResources
     */
    cpuShares?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof NodeCpuResources
     */
    reservableCpuCores?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof NodeCpuResources
     */
    totalCpuCores?: number;
}
/**
 * 
 * @export
 * @interface NodeDevice
 */
export interface NodeDevice {
    /**
     * 
     * @type {string}
     * @memberof NodeDevice
     */
    healthDescription?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NodeDevice
     */
    healthy?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NodeDevice
     */
    ID?: string;
    /**
     * 
     * @type {NodeDeviceLocality}
     * @memberof NodeDevice
     */
    locality?: NodeDeviceLocality;
}
/**
 * 
 * @export
 * @interface NodeDeviceLocality
 */
export interface NodeDeviceLocality {
    /**
     * 
     * @type {string}
     * @memberof NodeDeviceLocality
     */
    pciBusID?: string;
}
/**
 * 
 * @export
 * @interface NodeDeviceResource
 */
export interface NodeDeviceResource {
    /**
     * 
     * @type {{ [key: string]: Attribute; }}
     * @memberof NodeDeviceResource
     */
    attributes?: { [key: string]: Attribute; };
    /**
     * 
     * @type {Array<NodeDevice>}
     * @memberof NodeDeviceResource
     */
    instances?: Array<NodeDevice>;
    /**
     * 
     * @type {string}
     * @memberof NodeDeviceResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeDeviceResource
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeDeviceResource
     */
    vendor?: string;
}
/**
 * 
 * @export
 * @interface NodeDiskResources
 */
export interface NodeDiskResources {
    /**
     * 
     * @type {number}
     * @memberof NodeDiskResources
     */
    diskMB?: number;
}
/**
 * 
 * @export
 * @interface NodeDrainUpdateResponse
 */
export interface NodeDrainUpdateResponse {
    /**
     * 
     * @type {number}
     * @memberof NodeDrainUpdateResponse
     */
    evalCreateIndex?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof NodeDrainUpdateResponse
     */
    evalIDs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof NodeDrainUpdateResponse
     */
    lastIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeDrainUpdateResponse
     */
    nodeModifyIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeDrainUpdateResponse
     */
    requestTime?: number;
}
/**
 * 
 * @export
 * @interface NodeEligibilityUpdateResponse
 */
export interface NodeEligibilityUpdateResponse {
    /**
     * 
     * @type {number}
     * @memberof NodeEligibilityUpdateResponse
     */
    evalCreateIndex?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof NodeEligibilityUpdateResponse
     */
    evalIDs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof NodeEligibilityUpdateResponse
     */
    lastIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeEligibilityUpdateResponse
     */
    nodeModifyIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeEligibilityUpdateResponse
     */
    requestTime?: number;
}
/**
 * 
 * @export
 * @interface NodeEvent
 */
export interface NodeEvent {
    /**
     * 
     * @type {number}
     * @memberof NodeEvent
     */
    createIndex?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof NodeEvent
     */
    details?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof NodeEvent
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeEvent
     */
    subsystem?: string;
    /**
     * 
     * @type {Date}
     * @memberof NodeEvent
     */
    timestamp?: Date;
}
/**
 * 
 * @export
 * @interface NodeListStub
 */
export interface NodeListStub {
    /**
     * 
     * @type {string}
     * @memberof NodeListStub
     */
    address?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof NodeListStub
     */
    attributes?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof NodeListStub
     */
    createIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof NodeListStub
     */
    datacenter?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NodeListStub
     */
    drain?: boolean;
    /**
     * 
     * @type {{ [key: string]: DriverInfo; }}
     * @memberof NodeListStub
     */
    drivers?: { [key: string]: DriverInfo; };
    /**
     * 
     * @type {string}
     * @memberof NodeListStub
     */
    ID?: string;
    /**
     * 
     * @type {DrainMetadata}
     * @memberof NodeListStub
     */
    lastDrain?: DrainMetadata;
    /**
     * 
     * @type {number}
     * @memberof NodeListStub
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof NodeListStub
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeListStub
     */
    nodeClass?: string;
    /**
     * 
     * @type {NodeResources}
     * @memberof NodeListStub
     */
    nodeResources?: NodeResources;
    /**
     * 
     * @type {NodeReservedResources}
     * @memberof NodeListStub
     */
    reservedResources?: NodeReservedResources;
    /**
     * 
     * @type {string}
     * @memberof NodeListStub
     */
    schedulingEligibility?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeListStub
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeListStub
     */
    statusDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeListStub
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface NodeMemoryResources
 */
export interface NodeMemoryResources {
    /**
     * 
     * @type {number}
     * @memberof NodeMemoryResources
     */
    memoryMB?: number;
}
/**
 * 
 * @export
 * @interface NodePurgeResponse
 */
export interface NodePurgeResponse {
    /**
     * 
     * @type {number}
     * @memberof NodePurgeResponse
     */
    evalCreateIndex?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof NodePurgeResponse
     */
    evalIDs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof NodePurgeResponse
     */
    nodeModifyIndex?: number;
}
/**
 * 
 * @export
 * @interface NodeReservedCpuResources
 */
export interface NodeReservedCpuResources {
    /**
     * 
     * @type {number}
     * @memberof NodeReservedCpuResources
     */
    cpuShares?: number;
}
/**
 * 
 * @export
 * @interface NodeReservedDiskResources
 */
export interface NodeReservedDiskResources {
    /**
     * 
     * @type {number}
     * @memberof NodeReservedDiskResources
     */
    diskMB?: number;
}
/**
 * 
 * @export
 * @interface NodeReservedMemoryResources
 */
export interface NodeReservedMemoryResources {
    /**
     * 
     * @type {number}
     * @memberof NodeReservedMemoryResources
     */
    memoryMB?: number;
}
/**
 * 
 * @export
 * @interface NodeReservedNetworkResources
 */
export interface NodeReservedNetworkResources {
    /**
     * 
     * @type {string}
     * @memberof NodeReservedNetworkResources
     */
    reservedHostPorts?: string;
}
/**
 * 
 * @export
 * @interface NodeReservedResources
 */
export interface NodeReservedResources {
    /**
     * 
     * @type {NodeReservedCpuResources}
     * @memberof NodeReservedResources
     */
    cpu?: NodeReservedCpuResources;
    /**
     * 
     * @type {NodeReservedDiskResources}
     * @memberof NodeReservedResources
     */
    disk?: NodeReservedDiskResources;
    /**
     * 
     * @type {NodeReservedMemoryResources}
     * @memberof NodeReservedResources
     */
    memory?: NodeReservedMemoryResources;
    /**
     * 
     * @type {NodeReservedNetworkResources}
     * @memberof NodeReservedResources
     */
    networks?: NodeReservedNetworkResources;
}
/**
 * 
 * @export
 * @interface NodeResources
 */
export interface NodeResources {
    /**
     * 
     * @type {NodeCpuResources}
     * @memberof NodeResources
     */
    cpu?: NodeCpuResources;
    /**
     * 
     * @type {Array<NodeDeviceResource>}
     * @memberof NodeResources
     */
    devices?: Array<NodeDeviceResource>;
    /**
     * 
     * @type {NodeDiskResources}
     * @memberof NodeResources
     */
    disk?: NodeDiskResources;
    /**
     * 
     * @type {number}
     * @memberof NodeResources
     */
    maxDynamicPort?: number;
    /**
     * 
     * @type {NodeMemoryResources}
     * @memberof NodeResources
     */
    memory?: NodeMemoryResources;
    /**
     * 
     * @type {number}
     * @memberof NodeResources
     */
    minDynamicPort?: number;
    /**
     * 
     * @type {Array<NetworkResource>}
     * @memberof NodeResources
     */
    networks?: Array<NetworkResource>;
}
/**
 * 
 * @export
 * @interface NodeScoreMeta
 */
export interface NodeScoreMeta {
    /**
     * 
     * @type {string}
     * @memberof NodeScoreMeta
     */
    nodeID?: string;
    /**
     * 
     * @type {number}
     * @memberof NodeScoreMeta
     */
    normScore?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof NodeScoreMeta
     */
    scores?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface NodeUpdateDrainRequest
 */
export interface NodeUpdateDrainRequest {
    /**
     * 
     * @type {DrainSpec}
     * @memberof NodeUpdateDrainRequest
     */
    drainSpec?: DrainSpec;
    /**
     * 
     * @type {boolean}
     * @memberof NodeUpdateDrainRequest
     */
    markEligible?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof NodeUpdateDrainRequest
     */
    meta?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof NodeUpdateDrainRequest
     */
    nodeID?: string;
}
/**
 * 
 * @export
 * @interface NodeUpdateEligibilityRequest
 */
export interface NodeUpdateEligibilityRequest {
    /**
     * 
     * @type {string}
     * @memberof NodeUpdateEligibilityRequest
     */
    eligibility?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeUpdateEligibilityRequest
     */
    nodeID?: string;
}
/**
 * 
 * @export
 * @interface ObjectDiff
 */
export interface ObjectDiff {
    /**
     * 
     * @type {Array<FieldDiff>}
     * @memberof ObjectDiff
     */
    fields?: Array<FieldDiff>;
    /**
     * 
     * @type {string}
     * @memberof ObjectDiff
     */
    name?: string;
    /**
     * 
     * @type {Array<ObjectDiff>}
     * @memberof ObjectDiff
     */
    objects?: Array<ObjectDiff>;
    /**
     * 
     * @type {string}
     * @memberof ObjectDiff
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface OneTimeToken
 */
export interface OneTimeToken {
    /**
     * 
     * @type {string}
     * @memberof OneTimeToken
     */
    accessorID?: string;
    /**
     * 
     * @type {number}
     * @memberof OneTimeToken
     */
    createIndex?: number;
    /**
     * 
     * @type {Date}
     * @memberof OneTimeToken
     */
    expiresAt?: Date;
    /**
     * 
     * @type {number}
     * @memberof OneTimeToken
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof OneTimeToken
     */
    oneTimeSecretID?: string;
}
/**
 * 
 * @export
 * @interface OneTimeTokenExchangeRequest
 */
export interface OneTimeTokenExchangeRequest {
    /**
     * 
     * @type {string}
     * @memberof OneTimeTokenExchangeRequest
     */
    oneTimeSecretID?: string;
}
/**
 * 
 * @export
 * @interface OperatorHealthReply
 */
export interface OperatorHealthReply {
    /**
     * 
     * @type {number}
     * @memberof OperatorHealthReply
     */
    failureTolerance?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OperatorHealthReply
     */
    healthy?: boolean;
    /**
     * 
     * @type {Array<ServerHealth>}
     * @memberof OperatorHealthReply
     */
    servers?: Array<ServerHealth>;
}
/**
 * 
 * @export
 * @interface ParameterizedJobConfig
 */
export interface ParameterizedJobConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof ParameterizedJobConfig
     */
    metaOptional?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParameterizedJobConfig
     */
    metaRequired?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ParameterizedJobConfig
     */
    payload?: string;
}
/**
 * 
 * @export
 * @interface PeriodicConfig
 */
export interface PeriodicConfig {
    /**
     * 
     * @type {boolean}
     * @memberof PeriodicConfig
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PeriodicConfig
     */
    prohibitOverlap?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PeriodicConfig
     */
    spec?: string;
    /**
     * 
     * @type {string}
     * @memberof PeriodicConfig
     */
    specType?: string;
    /**
     * 
     * @type {string}
     * @memberof PeriodicConfig
     */
    timeZone?: string;
}
/**
 * 
 * @export
 * @interface PeriodicForceResponse
 */
export interface PeriodicForceResponse {
    /**
     * 
     * @type {number}
     * @memberof PeriodicForceResponse
     */
    evalCreateIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof PeriodicForceResponse
     */
    evalID?: string;
    /**
     * 
     * @type {number}
     * @memberof PeriodicForceResponse
     */
    index?: number;
}
/**
 * 
 * @export
 * @interface PlanAnnotations
 */
export interface PlanAnnotations {
    /**
     * 
     * @type {{ [key: string]: DesiredUpdates; }}
     * @memberof PlanAnnotations
     */
    desiredTGUpdates?: { [key: string]: DesiredUpdates; };
    /**
     * 
     * @type {Array<AllocationListStub>}
     * @memberof PlanAnnotations
     */
    preemptedAllocs?: Array<AllocationListStub>;
}
/**
 * 
 * @export
 * @interface PointValue
 */
export interface PointValue {
    /**
     * 
     * @type {string}
     * @memberof PointValue
     */
    name?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PointValue
     */
    points?: Array<number>;
}
/**
 * 
 * @export
 * @interface Port
 */
export interface Port {
    /**
     * 
     * @type {string}
     * @memberof Port
     */
    hostNetwork?: string;
    /**
     * 
     * @type {string}
     * @memberof Port
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof Port
     */
    to?: number;
    /**
     * 
     * @type {number}
     * @memberof Port
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface PortMapping
 */
export interface PortMapping {
    /**
     * 
     * @type {string}
     * @memberof PortMapping
     */
    hostIP?: string;
    /**
     * 
     * @type {string}
     * @memberof PortMapping
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof PortMapping
     */
    to?: number;
    /**
     * 
     * @type {number}
     * @memberof PortMapping
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface PreemptionConfig
 */
export interface PreemptionConfig {
    /**
     * 
     * @type {boolean}
     * @memberof PreemptionConfig
     */
    batchSchedulerEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PreemptionConfig
     */
    serviceSchedulerEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PreemptionConfig
     */
    sysBatchSchedulerEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PreemptionConfig
     */
    systemSchedulerEnabled?: boolean;
}
/**
 * 
 * @export
 * @interface QuotaLimit
 */
export interface QuotaLimit {
    /**
     * 
     * @type {string}
     * @memberof QuotaLimit
     */
    hash?: string;
    /**
     * 
     * @type {string}
     * @memberof QuotaLimit
     */
    region?: string;
    /**
     * 
     * @type {Resources}
     * @memberof QuotaLimit
     */
    regionLimit?: Resources;
    /**
     * 
     * @type {number}
     * @memberof QuotaLimit
     */
    variablesLimit?: number;
}
/**
 * 
 * @export
 * @interface QuotaSpec
 */
export interface QuotaSpec {
    /**
     * 
     * @type {number}
     * @memberof QuotaSpec
     */
    createIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof QuotaSpec
     */
    description?: string;
    /**
     * 
     * @type {Array<QuotaLimit>}
     * @memberof QuotaSpec
     */
    limits?: Array<QuotaLimit>;
    /**
     * 
     * @type {number}
     * @memberof QuotaSpec
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof QuotaSpec
     */
    name?: string;
}
/**
 * 
 * @export
 */
export type Quotas = any
/**
 * 
 * @export
 * @interface RaftConfiguration
 */
export interface RaftConfiguration {
    /**
     * 
     * @type {number}
     * @memberof RaftConfiguration
     */
    index?: number;
    /**
     * 
     * @type {Array<RaftServer>}
     * @memberof RaftConfiguration
     */
    servers?: Array<RaftServer>;
}
/**
 * 
 * @export
 * @interface RaftServer
 */
export interface RaftServer {
    /**
     * 
     * @type {string}
     * @memberof RaftServer
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof RaftServer
     */
    ID?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RaftServer
     */
    leader?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RaftServer
     */
    node?: string;
    /**
     * 
     * @type {string}
     * @memberof RaftServer
     */
    raftProtocol?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RaftServer
     */
    voter?: boolean;
}
/**
 * 
 * @export
 * @interface RequestedDevice
 */
export interface RequestedDevice {
    /**
     * 
     * @type {Array<Affinity>}
     * @memberof RequestedDevice
     */
    affinities?: Array<Affinity>;
    /**
     * 
     * @type {Array<Constraint>}
     * @memberof RequestedDevice
     */
    constraints?: Array<Constraint>;
    /**
     * 
     * @type {number}
     * @memberof RequestedDevice
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof RequestedDevice
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface RescheduleEvent
 */
export interface RescheduleEvent {
    /**
     * 
     * @type {string}
     * @memberof RescheduleEvent
     */
    prevAllocID?: string;
    /**
     * 
     * @type {string}
     * @memberof RescheduleEvent
     */
    prevNodeID?: string;
    /**
     * 
     * @type {number}
     * @memberof RescheduleEvent
     */
    rescheduleTime?: number;
}
/**
 * 
 * @export
 * @interface ReschedulePolicy
 */
export interface ReschedulePolicy {
    /**
     * 
     * @type {number}
     * @memberof ReschedulePolicy
     */
    attempts?: number;
    /**
     * 
     * @type {number}
     * @memberof ReschedulePolicy
     */
    delay?: number;
    /**
     * 
     * @type {string}
     * @memberof ReschedulePolicy
     */
    delayFunction?: string;
    /**
     * 
     * @type {number}
     * @memberof ReschedulePolicy
     */
    interval?: number;
    /**
     * 
     * @type {number}
     * @memberof ReschedulePolicy
     */
    maxDelay?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ReschedulePolicy
     */
    unlimited?: boolean;
}
/**
 * 
 * @export
 * @interface RescheduleTracker
 */
export interface RescheduleTracker {
    /**
     * 
     * @type {Array<RescheduleEvent>}
     * @memberof RescheduleTracker
     */
    events?: Array<RescheduleEvent>;
}
/**
 * 
 * @export
 * @interface Resources
 */
export interface Resources {
    /**
     * 
     * @type {number}
     * @memberof Resources
     */
    CPU?: number;
    /**
     * 
     * @type {number}
     * @memberof Resources
     */
    cores?: number;
    /**
     * 
     * @type {Array<RequestedDevice>}
     * @memberof Resources
     */
    devices?: Array<RequestedDevice>;
    /**
     * 
     * @type {number}
     * @memberof Resources
     */
    diskMB?: number;
    /**
     * 
     * @type {number}
     * @memberof Resources
     */
    IOPS?: number;
    /**
     * 
     * @type {number}
     * @memberof Resources
     */
    memoryMB?: number;
    /**
     * 
     * @type {number}
     * @memberof Resources
     */
    memoryMaxMB?: number;
    /**
     * 
     * @type {Array<NetworkResource>}
     * @memberof Resources
     */
    networks?: Array<NetworkResource>;
}
/**
 * 
 * @export
 * @interface RestartPolicy
 */
export interface RestartPolicy {
    /**
     * 
     * @type {number}
     * @memberof RestartPolicy
     */
    attempts?: number;
    /**
     * 
     * @type {number}
     * @memberof RestartPolicy
     */
    delay?: number;
    /**
     * 
     * @type {number}
     * @memberof RestartPolicy
     */
    interval?: number;
    /**
     * 
     * @type {string}
     * @memberof RestartPolicy
     */
    mode?: string;
}
/**
 * 
 * @export
 * @interface SampledValue
 */
export interface SampledValue {
    /**
     * 
     * @type {number}
     * @memberof SampledValue
     */
    count?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SampledValue
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof SampledValue
     */
    max?: number;
    /**
     * 
     * @type {number}
     * @memberof SampledValue
     */
    mean?: number;
    /**
     * 
     * @type {number}
     * @memberof SampledValue
     */
    min?: number;
    /**
     * 
     * @type {string}
     * @memberof SampledValue
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof SampledValue
     */
    rate?: number;
    /**
     * 
     * @type {number}
     * @memberof SampledValue
     */
    stddev?: number;
    /**
     * 
     * @type {number}
     * @memberof SampledValue
     */
    sum?: number;
}
/**
 * 
 * @export
 * @interface ScalingEvent
 */
export interface ScalingEvent {
    /**
     * 
     * @type {number}
     * @memberof ScalingEvent
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof ScalingEvent
     */
    createIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScalingEvent
     */
    error?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScalingEvent
     */
    evalID?: string;
    /**
     * 
     * @type {string}
     * @memberof ScalingEvent
     */
    message?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ScalingEvent
     */
    meta?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof ScalingEvent
     */
    previousCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ScalingEvent
     */
    time?: number;
}
/**
 * 
 * @export
 * @interface ScalingPolicy
 */
export interface ScalingPolicy {
    /**
     * 
     * @type {number}
     * @memberof ScalingPolicy
     */
    createIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScalingPolicy
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScalingPolicy
     */
    ID?: string;
    /**
     * 
     * @type {number}
     * @memberof ScalingPolicy
     */
    max?: number;
    /**
     * 
     * @type {number}
     * @memberof ScalingPolicy
     */
    min?: number;
    /**
     * 
     * @type {number}
     * @memberof ScalingPolicy
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof ScalingPolicy
     */
    namespace?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ScalingPolicy
     */
    policy?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ScalingPolicy
     */
    target?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ScalingPolicy
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface ScalingPolicyListStub
 */
export interface ScalingPolicyListStub {
    /**
     * 
     * @type {number}
     * @memberof ScalingPolicyListStub
     */
    createIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScalingPolicyListStub
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScalingPolicyListStub
     */
    ID?: string;
    /**
     * 
     * @type {number}
     * @memberof ScalingPolicyListStub
     */
    modifyIndex?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ScalingPolicyListStub
     */
    target?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ScalingPolicyListStub
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface ScalingRequest
 */
export interface ScalingRequest {
    /**
     * 
     * @type {number}
     * @memberof ScalingRequest
     */
    count?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScalingRequest
     */
    error?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScalingRequest
     */
    message?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ScalingRequest
     */
    meta?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ScalingRequest
     */
    namespace?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScalingRequest
     */
    policyOverride?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScalingRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof ScalingRequest
     */
    secretID?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ScalingRequest
     */
    target?: { [key: string]: string; };
}
/**
 * 
 * @export
 */
export type SchedulerAlgorithm = string
/**
 * 
 * @export
 * @interface SchedulerConfiguration
 */
export interface SchedulerConfiguration {
    /**
     * 
     * @type {number}
     * @memberof SchedulerConfiguration
     */
    createIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SchedulerConfiguration
     */
    memoryOversubscriptionEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SchedulerConfiguration
     */
    modifyIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SchedulerConfiguration
     */
    pauseEvalBroker?: boolean;
    /**
     * 
     * @type {PreemptionConfig}
     * @memberof SchedulerConfiguration
     */
    preemptionConfig?: PreemptionConfig;
    /**
     * 
     * @type {boolean}
     * @memberof SchedulerConfiguration
     */
    rejectJobRegistration?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SchedulerConfiguration
     */
    schedulerAlgorithm?: string;
}
/**
 * 
 * @export
 * @interface SchedulerConfigurationResponse
 */
export interface SchedulerConfigurationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SchedulerConfigurationResponse
     */
    knownLeader?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SchedulerConfigurationResponse
     */
    lastContact?: number;
    /**
     * 
     * @type {number}
     * @memberof SchedulerConfigurationResponse
     */
    lastIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof SchedulerConfigurationResponse
     */
    nextToken?: string;
    /**
     * 
     * @type {number}
     * @memberof SchedulerConfigurationResponse
     */
    requestTime?: number;
    /**
     * 
     * @type {SchedulerConfiguration}
     * @memberof SchedulerConfigurationResponse
     */
    schedulerConfig?: SchedulerConfiguration;
}
/**
 * 
 * @export
 * @interface SchedulerSetConfigurationResponse
 */
export interface SchedulerSetConfigurationResponse {
    /**
     * 
     * @type {number}
     * @memberof SchedulerSetConfigurationResponse
     */
    lastIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof SchedulerSetConfigurationResponse
     */
    requestTime?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SchedulerSetConfigurationResponse
     */
    updated?: boolean;
}
/**
 * 
 * @export
 * @interface SearchRequest
 */
export interface SearchRequest {
    /**
     * 
     * @type {boolean}
     * @memberof SearchRequest
     */
    allowStale?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    authToken?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    context?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    filter?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SearchRequest
     */
    headers?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    nextToken?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SearchRequest
     */
    params?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof SearchRequest
     */
    perPage?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    prefix?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    region?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SearchRequest
     */
    reverse?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SearchRequest
     */
    waitIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchRequest
     */
    waitTime?: number;
}
/**
 * 
 * @export
 * @interface SearchResponse
 */
export interface SearchResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SearchResponse
     */
    knownLeader?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SearchResponse
     */
    lastContact?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchResponse
     */
    lastIndex?: number;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof SearchResponse
     */
    matches?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {string}
     * @memberof SearchResponse
     */
    nextToken?: string;
    /**
     * 
     * @type {number}
     * @memberof SearchResponse
     */
    requestTime?: number;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof SearchResponse
     */
    truncations?: { [key: string]: boolean; };
}
/**
 * 
 * @export
 * @interface ServerHealth
 */
export interface ServerHealth {
    /**
     * 
     * @type {string}
     * @memberof ServerHealth
     */
    address?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServerHealth
     */
    healthy?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServerHealth
     */
    ID?: string;
    /**
     * 
     * @type {number}
     * @memberof ServerHealth
     */
    lastContact?: number;
    /**
     * 
     * @type {number}
     * @memberof ServerHealth
     */
    lastIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof ServerHealth
     */
    lastTerm?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServerHealth
     */
    leader?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServerHealth
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ServerHealth
     */
    serfStatus?: string;
    /**
     * 
     * @type {Date}
     * @memberof ServerHealth
     */
    stableSince?: Date;
    /**
     * 
     * @type {string}
     * @memberof ServerHealth
     */
    version?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServerHealth
     */
    voter?: boolean;
}
/**
 * 
 * @export
 * @interface Service
 */
export interface Service {
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    addressMode?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Service
     */
    canaryMeta?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Service
     */
    canaryTags?: Array<string>;
    /**
     * 
     * @type {CheckRestart}
     * @memberof Service
     */
    checkRestart?: CheckRestart;
    /**
     * 
     * @type {Array<ServiceCheck>}
     * @memberof Service
     */
    checks?: Array<ServiceCheck>;
    /**
     * 
     * @type {ConsulConnect}
     * @memberof Service
     */
    connect?: ConsulConnect;
    /**
     * 
     * @type {boolean}
     * @memberof Service
     */
    enableTagOverride?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Service
     */
    meta?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    onUpdate?: string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    portLabel?: string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    provider?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Service
     */
    taggedAddresses?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Service
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    taskName?: string;
}
/**
 * 
 * @export
 * @interface ServiceCheck
 */
export interface ServiceCheck {
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    addressMode?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    advertise?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceCheck
     */
    args?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    body?: string;
    /**
     * 
     * @type {CheckRestart}
     * @memberof ServiceCheck
     */
    checkRestart?: CheckRestart;
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    command?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCheck
     */
    expose?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServiceCheck
     */
    failuresBeforeCritical?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    gRPCService?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCheck
     */
    gRPCUseTLS?: boolean;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ServiceCheck
     */
    header?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    initialStatus?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceCheck
     */
    interval?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    method?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    onUpdate?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    portLabel?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    protocol?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceCheck
     */
    successBeforePassing?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCheck
     */
    tLSSkipVerify?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    taskName?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceCheck
     */
    timeout?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceCheck
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface ServiceRegistration
 */
export interface ServiceRegistration {
    /**
     * 
     * @type {string}
     * @memberof ServiceRegistration
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRegistration
     */
    allocID?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceRegistration
     */
    createIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceRegistration
     */
    datacenter?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRegistration
     */
    ID?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRegistration
     */
    jobID?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceRegistration
     */
    modifyIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceRegistration
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRegistration
     */
    nodeID?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceRegistration
     */
    port?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceRegistration
     */
    serviceName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceRegistration
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface SidecarTask
 */
export interface SidecarTask {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SidecarTask
     */
    config?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof SidecarTask
     */
    driver?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SidecarTask
     */
    env?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof SidecarTask
     */
    killSignal?: string;
    /**
     * 
     * @type {number}
     * @memberof SidecarTask
     */
    killTimeout?: number;
    /**
     * 
     * @type {LogConfig}
     * @memberof SidecarTask
     */
    logConfig?: LogConfig;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SidecarTask
     */
    meta?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof SidecarTask
     */
    name?: string;
    /**
     * 
     * @type {Resources}
     * @memberof SidecarTask
     */
    resources?: Resources;
    /**
     * 
     * @type {number}
     * @memberof SidecarTask
     */
    shutdownDelay?: number;
    /**
     * 
     * @type {string}
     * @memberof SidecarTask
     */
    user?: string;
}
/**
 * 
 * @export
 * @interface Spread
 */
export interface Spread {
    /**
     * 
     * @type {string}
     * @memberof Spread
     */
    attribute?: string;
    /**
     * 
     * @type {Array<SpreadTarget>}
     * @memberof Spread
     */
    spreadTarget?: Array<SpreadTarget>;
    /**
     * 
     * @type {number}
     * @memberof Spread
     */
    weight?: number;
}
/**
 * 
 * @export
 * @interface SpreadTarget
 */
export interface SpreadTarget {
    /**
     * 
     * @type {number}
     * @memberof SpreadTarget
     */
    percent?: number;
    /**
     * 
     * @type {string}
     * @memberof SpreadTarget
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {Array<Affinity>}
     * @memberof Task
     */
    affinities?: Array<Affinity>;
    /**
     * 
     * @type {Array<TaskArtifact>}
     * @memberof Task
     */
    artifacts?: Array<TaskArtifact>;
    /**
     * 
     * @type {TaskCSIPluginConfig}
     * @memberof Task
     */
    cSIPluginConfig?: TaskCSIPluginConfig;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Task
     */
    config?: { [key: string]: any; };
    /**
     * 
     * @type {Array<Constraint>}
     * @memberof Task
     */
    constraints?: Array<Constraint>;
    /**
     * 
     * @type {DispatchPayloadConfig}
     * @memberof Task
     */
    dispatchPayload?: DispatchPayloadConfig;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    driver?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Task
     */
    env?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    killSignal?: string;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    killTimeout?: number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    kind?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Task
     */
    leader?: boolean;
    /**
     * 
     * @type {TaskLifecycle}
     * @memberof Task
     */
    lifecycle?: TaskLifecycle;
    /**
     * 
     * @type {LogConfig}
     * @memberof Task
     */
    logConfig?: LogConfig;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Task
     */
    meta?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    name?: string;
    /**
     * 
     * @type {Resources}
     * @memberof Task
     */
    resources?: Resources;
    /**
     * 
     * @type {RestartPolicy}
     * @memberof Task
     */
    restartPolicy?: RestartPolicy;
    /**
     * 
     * @type {Array<ScalingPolicy>}
     * @memberof Task
     */
    scalingPolicies?: Array<ScalingPolicy>;
    /**
     * 
     * @type {Array<Service>}
     * @memberof Task
     */
    services?: Array<Service>;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    shutdownDelay?: number;
    /**
     * 
     * @type {Array<Template>}
     * @memberof Task
     */
    templates?: Array<Template>;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    user?: string;
    /**
     * 
     * @type {Vault}
     * @memberof Task
     */
    vault?: Vault;
    /**
     * 
     * @type {Array<VolumeMount>}
     * @memberof Task
     */
    volumeMounts?: Array<VolumeMount>;
}
/**
 * 
 * @export
 * @interface TaskArtifact
 */
export interface TaskArtifact {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TaskArtifact
     */
    getterHeaders?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof TaskArtifact
     */
    getterMode?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TaskArtifact
     */
    getterOptions?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof TaskArtifact
     */
    getterSource?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskArtifact
     */
    relativeDest?: string;
}
/**
 * 
 * @export
 * @interface TaskCSIPluginConfig
 */
export interface TaskCSIPluginConfig {
    /**
     * 
     * @type {number}
     * @memberof TaskCSIPluginConfig
     */
    healthTimeout?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskCSIPluginConfig
     */
    ID?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskCSIPluginConfig
     */
    mountDir?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskCSIPluginConfig
     */
    stagePublishBaseDir?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskCSIPluginConfig
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface TaskDiff
 */
export interface TaskDiff {
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskDiff
     */
    annotations?: Array<string>;
    /**
     * 
     * @type {Array<FieldDiff>}
     * @memberof TaskDiff
     */
    fields?: Array<FieldDiff>;
    /**
     * 
     * @type {string}
     * @memberof TaskDiff
     */
    name?: string;
    /**
     * 
     * @type {Array<ObjectDiff>}
     * @memberof TaskDiff
     */
    objects?: Array<ObjectDiff>;
    /**
     * 
     * @type {string}
     * @memberof TaskDiff
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface TaskEvent
 */
export interface TaskEvent {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TaskEvent
     */
    details?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof TaskEvent
     */
    diskLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskEvent
     */
    diskSize?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    displayMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    downloadError?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    driverError?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    driverMessage?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskEvent
     */
    exitCode?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    failedSibling?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TaskEvent
     */
    failsTask?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    genericSource?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    killError?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    killReason?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskEvent
     */
    killTimeout?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    restartReason?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    setupError?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskEvent
     */
    signal?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskEvent
     */
    startDelay?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    taskSignal?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    taskSignalReason?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskEvent
     */
    time?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    validationError?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskEvent
     */
    vaultError?: string;
}
/**
 * 
 * @export
 * @interface TaskGroup
 */
export interface TaskGroup {
    /**
     * 
     * @type {Array<Affinity>}
     * @memberof TaskGroup
     */
    affinities?: Array<Affinity>;
    /**
     * 
     * @type {Array<Constraint>}
     * @memberof TaskGroup
     */
    constraints?: Array<Constraint>;
    /**
     * 
     * @type {Consul}
     * @memberof TaskGroup
     */
    consul?: Consul;
    /**
     * 
     * @type {number}
     * @memberof TaskGroup
     */
    count?: number;
    /**
     * 
     * @type {EphemeralDisk}
     * @memberof TaskGroup
     */
    ephemeralDisk?: EphemeralDisk;
    /**
     * 
     * @type {number}
     * @memberof TaskGroup
     */
    maxClientDisconnect?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TaskGroup
     */
    meta?: { [key: string]: string; };
    /**
     * 
     * @type {MigrateStrategy}
     * @memberof TaskGroup
     */
    migrate?: MigrateStrategy;
    /**
     * 
     * @type {string}
     * @memberof TaskGroup
     */
    name?: string;
    /**
     * 
     * @type {Array<NetworkResource>}
     * @memberof TaskGroup
     */
    networks?: Array<NetworkResource>;
    /**
     * 
     * @type {ReschedulePolicy}
     * @memberof TaskGroup
     */
    reschedulePolicy?: ReschedulePolicy;
    /**
     * 
     * @type {RestartPolicy}
     * @memberof TaskGroup
     */
    restartPolicy?: RestartPolicy;
    /**
     * 
     * @type {ScalingPolicy}
     * @memberof TaskGroup
     */
    scaling?: ScalingPolicy;
    /**
     * 
     * @type {Array<Service>}
     * @memberof TaskGroup
     */
    services?: Array<Service>;
    /**
     * 
     * @type {number}
     * @memberof TaskGroup
     */
    shutdownDelay?: number;
    /**
     * 
     * @type {Array<Spread>}
     * @memberof TaskGroup
     */
    spreads?: Array<Spread>;
    /**
     * 
     * @type {number}
     * @memberof TaskGroup
     */
    stopAfterClientDisconnect?: number;
    /**
     * 
     * @type {Array<Task>}
     * @memberof TaskGroup
     */
    tasks?: Array<Task>;
    /**
     * 
     * @type {UpdateStrategy}
     * @memberof TaskGroup
     */
    update?: UpdateStrategy;
    /**
     * 
     * @type {{ [key: string]: VolumeRequest; }}
     * @memberof TaskGroup
     */
    volumes?: { [key: string]: VolumeRequest; };
}
/**
 * 
 * @export
 * @interface TaskGroupDiff
 */
export interface TaskGroupDiff {
    /**
     * 
     * @type {Array<FieldDiff>}
     * @memberof TaskGroupDiff
     */
    fields?: Array<FieldDiff>;
    /**
     * 
     * @type {string}
     * @memberof TaskGroupDiff
     */
    name?: string;
    /**
     * 
     * @type {Array<ObjectDiff>}
     * @memberof TaskGroupDiff
     */
    objects?: Array<ObjectDiff>;
    /**
     * 
     * @type {Array<TaskDiff>}
     * @memberof TaskGroupDiff
     */
    tasks?: Array<TaskDiff>;
    /**
     * 
     * @type {string}
     * @memberof TaskGroupDiff
     */
    type?: string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof TaskGroupDiff
     */
    updates?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface TaskGroupScaleStatus
 */
export interface TaskGroupScaleStatus {
    /**
     * 
     * @type {number}
     * @memberof TaskGroupScaleStatus
     */
    desired?: number;
    /**
     * 
     * @type {Array<ScalingEvent>}
     * @memberof TaskGroupScaleStatus
     */
    events?: Array<ScalingEvent>;
    /**
     * 
     * @type {number}
     * @memberof TaskGroupScaleStatus
     */
    healthy?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskGroupScaleStatus
     */
    placed?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskGroupScaleStatus
     */
    running?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskGroupScaleStatus
     */
    unhealthy?: number;
}
/**
 * 
 * @export
 * @interface TaskGroupSummary
 */
export interface TaskGroupSummary {
    /**
     * 
     * @type {number}
     * @memberof TaskGroupSummary
     */
    complete?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskGroupSummary
     */
    failed?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskGroupSummary
     */
    lost?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskGroupSummary
     */
    queued?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskGroupSummary
     */
    running?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskGroupSummary
     */
    starting?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskGroupSummary
     */
    unknown?: number;
}
/**
 * 
 * @export
 * @interface TaskHandle
 */
export interface TaskHandle {
    /**
     * 
     * @type {string}
     * @memberof TaskHandle
     */
    driverState?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskHandle
     */
    version?: number;
}
/**
 * 
 * @export
 * @interface TaskLifecycle
 */
export interface TaskLifecycle {
    /**
     * 
     * @type {string}
     * @memberof TaskLifecycle
     */
    hook?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TaskLifecycle
     */
    sidecar?: boolean;
}
/**
 * 
 * @export
 * @interface TaskState
 */
export interface TaskState {
    /**
     * 
     * @type {Array<TaskEvent>}
     * @memberof TaskState
     */
    events?: Array<TaskEvent>;
    /**
     * 
     * @type {boolean}
     * @memberof TaskState
     */
    failed?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof TaskState
     */
    finishedAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TaskState
     */
    lastRestart?: Date;
    /**
     * 
     * @type {number}
     * @memberof TaskState
     */
    restarts?: number;
    /**
     * 
     * @type {Date}
     * @memberof TaskState
     */
    startedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof TaskState
     */
    state?: string;
    /**
     * 
     * @type {TaskHandle}
     * @memberof TaskState
     */
    taskHandle?: TaskHandle;
}
/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    changeMode?: string;
    /**
     * 
     * @type {ChangeScript}
     * @memberof Template
     */
    changeScript?: ChangeScript;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    changeSignal?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    destPath?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    embeddedTmpl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Template
     */
    envvars?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Template
     */
    gid?: number;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    leftDelim?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    perms?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    rightDelim?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    sourcePath?: string;
    /**
     * 
     * @type {number}
     * @memberof Template
     */
    splay?: number;
    /**
     * 
     * @type {number}
     * @memberof Template
     */
    uid?: number;
    /**
     * 
     * @type {number}
     * @memberof Template
     */
    vaultGrace?: number;
    /**
     * 
     * @type {WaitConfig}
     * @memberof Template
     */
    wait?: WaitConfig;
}
/**
 * 
 * @export
 */
export type Time = Date
/**
 * 
 * @export
 */
export type Uint = number
/**
 * 
 * @export
 */
export type Uint16 = number
/**
 * 
 * @export
 */
export type Uint64 = number
/**
 * 
 * @export
 */
export type Uint8 = number
/**
 * 
 * @export
 * @interface UpdateStrategy
 */
export interface UpdateStrategy {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateStrategy
     */
    autoPromote?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateStrategy
     */
    autoRevert?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateStrategy
     */
    canary?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateStrategy
     */
    healthCheck?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateStrategy
     */
    healthyDeadline?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateStrategy
     */
    maxParallel?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateStrategy
     */
    minHealthyTime?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateStrategy
     */
    progressDeadline?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateStrategy
     */
    stagger?: number;
}
/**
 * 
 * @export
 * @interface Variable
 */
export interface Variable {
    /**
     * 
     * @type {number}
     * @memberof Variable
     */
    createIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof Variable
     */
    createTime?: number;
    /**
     * 
     * @type {VariableItems}
     * @memberof Variable
     */
    items?: VariableItems;
    /**
     * 
     * @type {number}
     * @memberof Variable
     */
    modifyIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof Variable
     */
    modifyTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Variable
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof Variable
     */
    path?: string;
}
/**
 * 
 * @export
 * @interface VariableItems
 */
export interface VariableItems extends Record<string, string> {
    [key: string]: string;

}
/**
 * 
 * @export
 * @interface VariableMetadata
 */
export interface VariableMetadata {
    /**
     * 
     * @type {number}
     * @memberof VariableMetadata
     */
    createIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof VariableMetadata
     */
    createTime?: number;
    /**
     * 
     * @type {number}
     * @memberof VariableMetadata
     */
    modifyIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof VariableMetadata
     */
    modifyTime?: number;
    /**
     * 
     * @type {string}
     * @memberof VariableMetadata
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof VariableMetadata
     */
    path?: string;
}
/**
 * 
 * @export
 * @interface Vault
 */
export interface Vault {
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    changeMode?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    changeSignal?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Vault
     */
    env?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    namespace?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Vault
     */
    policies?: Array<string>;
}
/**
 * 
 * @export
 * @interface VolumeMount
 */
export interface VolumeMount {
    /**
     * 
     * @type {string}
     * @memberof VolumeMount
     */
    destination?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeMount
     */
    propagationMode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VolumeMount
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VolumeMount
     */
    volume?: string;
}
/**
 * 
 * @export
 * @interface VolumeRequest
 */
export interface VolumeRequest {
    /**
     * 
     * @type {string}
     * @memberof VolumeRequest
     */
    accessMode?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeRequest
     */
    attachmentMode?: string;
    /**
     * 
     * @type {CSIMountOptions}
     * @memberof VolumeRequest
     */
    mountOptions?: CSIMountOptions;
    /**
     * 
     * @type {string}
     * @memberof VolumeRequest
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VolumeRequest
     */
    perAlloc?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VolumeRequest
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VolumeRequest
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeRequest
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface WaitConfig
 */
export interface WaitConfig {
    /**
     * 
     * @type {number}
     * @memberof WaitConfig
     */
    max?: number;
    /**
     * 
     * @type {number}
     * @memberof WaitConfig
     */
    min?: number;
}
/**
 * ACLApi - fetch parameter creator
 * @export
 */
export const ACLApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} policyName The ACL policy name.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACLPolicy(policyName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'policyName' is not null or undefined
            if (policyName === null || policyName === undefined) {
                throw new RequiredError('policyName','Required parameter policyName was null or undefined when calling deleteACLPolicy.');
            }
            const localVarPath = `/acl/policy/{policyName}`
                .replace(`{${"policyName"}}`, encodeURIComponent(String(policyName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tokenAccessor The token accessor ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACLToken(tokenAccessor: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tokenAccessor' is not null or undefined
            if (tokenAccessor === null || tokenAccessor === undefined) {
                throw new RequiredError('tokenAccessor','Required parameter tokenAccessor was null or undefined when calling deleteACLToken.');
            }
            const localVarPath = `/acl/token/{tokenAccessor}`
                .replace(`{${"tokenAccessor"}}`, encodeURIComponent(String(tokenAccessor)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLPolicies(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/acl/policies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyName The ACL policy name.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLPolicy(policyName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'policyName' is not null or undefined
            if (policyName === null || policyName === undefined) {
                throw new RequiredError('policyName','Required parameter policyName was null or undefined when calling getACLPolicy.');
            }
            const localVarPath = `/acl/policy/{policyName}`
                .replace(`{${"policyName"}}`, encodeURIComponent(String(policyName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tokenAccessor The token accessor ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLToken(tokenAccessor: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tokenAccessor' is not null or undefined
            if (tokenAccessor === null || tokenAccessor === undefined) {
                throw new RequiredError('tokenAccessor','Required parameter tokenAccessor was null or undefined when calling getACLToken.');
            }
            const localVarPath = `/acl/token/{tokenAccessor}`
                .replace(`{${"tokenAccessor"}}`, encodeURIComponent(String(tokenAccessor)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLTokenSelf(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/acl/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLTokens(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/acl/tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLBootstrap(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/acl/bootstrap`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ACLPolicy} body 
         * @param {string} policyName The ACL policy name.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLPolicy(body: ACLPolicy, policyName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postACLPolicy.');
            }
            // verify required parameter 'policyName' is not null or undefined
            if (policyName === null || policyName === undefined) {
                throw new RequiredError('policyName','Required parameter policyName was null or undefined when calling postACLPolicy.');
            }
            const localVarPath = `/acl/policy/{policyName}`
                .replace(`{${"policyName"}}`, encodeURIComponent(String(policyName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ACLPolicy" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ACLToken} body 
         * @param {string} tokenAccessor The token accessor ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLToken(body: ACLToken, tokenAccessor: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postACLToken.');
            }
            // verify required parameter 'tokenAccessor' is not null or undefined
            if (tokenAccessor === null || tokenAccessor === undefined) {
                throw new RequiredError('tokenAccessor','Required parameter tokenAccessor was null or undefined when calling postACLToken.');
            }
            const localVarPath = `/acl/token/{tokenAccessor}`
                .replace(`{${"tokenAccessor"}}`, encodeURIComponent(String(tokenAccessor)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ACLToken" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLTokenOnetime(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/acl/token/onetime`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OneTimeTokenExchangeRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLTokenOnetimeExchange(body: OneTimeTokenExchangeRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postACLTokenOnetimeExchange.');
            }
            const localVarPath = `/acl/token/onetime/exchange`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OneTimeTokenExchangeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ACLApi - functional programming interface
 * @export
 */
export const ACLApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} policyName The ACL policy name.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACLPolicy(policyName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ACLApiFetchParamCreator(configuration).deleteACLPolicy(policyName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} tokenAccessor The token accessor ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACLToken(tokenAccessor: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ACLApiFetchParamCreator(configuration).deleteACLToken(tokenAccessor, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLPolicies(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ACLPolicyListStub>> {
            const localVarFetchArgs = ACLApiFetchParamCreator(configuration).getACLPolicies(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} policyName The ACL policy name.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLPolicy(policyName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ACLPolicy> {
            const localVarFetchArgs = ACLApiFetchParamCreator(configuration).getACLPolicy(policyName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} tokenAccessor The token accessor ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLToken(tokenAccessor: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ACLToken> {
            const localVarFetchArgs = ACLApiFetchParamCreator(configuration).getACLToken(tokenAccessor, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLTokenSelf(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ACLToken> {
            const localVarFetchArgs = ACLApiFetchParamCreator(configuration).getACLTokenSelf(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLTokens(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ACLTokenListStub>> {
            const localVarFetchArgs = ACLApiFetchParamCreator(configuration).getACLTokens(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLBootstrap(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ACLToken> {
            const localVarFetchArgs = ACLApiFetchParamCreator(configuration).postACLBootstrap(region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ACLPolicy} body 
         * @param {string} policyName The ACL policy name.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLPolicy(body: ACLPolicy, policyName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ACLApiFetchParamCreator(configuration).postACLPolicy(body, policyName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ACLToken} body 
         * @param {string} tokenAccessor The token accessor ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLToken(body: ACLToken, tokenAccessor: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ACLToken> {
            const localVarFetchArgs = ACLApiFetchParamCreator(configuration).postACLToken(body, tokenAccessor, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLTokenOnetime(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OneTimeToken> {
            const localVarFetchArgs = ACLApiFetchParamCreator(configuration).postACLTokenOnetime(region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {OneTimeTokenExchangeRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLTokenOnetimeExchange(body: OneTimeTokenExchangeRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ACLToken> {
            const localVarFetchArgs = ACLApiFetchParamCreator(configuration).postACLTokenOnetimeExchange(body, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ACLApi - factory interface
 * @export
 */
export const ACLApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} policyName The ACL policy name.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACLPolicy(policyName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return ACLApiFp(configuration).deleteACLPolicy(policyName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} tokenAccessor The token accessor ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACLToken(tokenAccessor: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return ACLApiFp(configuration).deleteACLToken(tokenAccessor, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLPolicies(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return ACLApiFp(configuration).getACLPolicies(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} policyName The ACL policy name.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLPolicy(policyName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return ACLApiFp(configuration).getACLPolicy(policyName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} tokenAccessor The token accessor ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLToken(tokenAccessor: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return ACLApiFp(configuration).getACLToken(tokenAccessor, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLTokenSelf(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return ACLApiFp(configuration).getACLTokenSelf(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACLTokens(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return ACLApiFp(configuration).getACLTokens(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLBootstrap(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return ACLApiFp(configuration).postACLBootstrap(region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ACLPolicy} body 
         * @param {string} policyName The ACL policy name.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLPolicy(body: ACLPolicy, policyName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return ACLApiFp(configuration).postACLPolicy(body, policyName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ACLToken} body 
         * @param {string} tokenAccessor The token accessor ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLToken(body: ACLToken, tokenAccessor: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return ACLApiFp(configuration).postACLToken(body, tokenAccessor, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLTokenOnetime(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return ACLApiFp(configuration).postACLTokenOnetime(region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {OneTimeTokenExchangeRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACLTokenOnetimeExchange(body: OneTimeTokenExchangeRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return ACLApiFp(configuration).postACLTokenOnetimeExchange(body, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
    };
};

/**
 * ACLApi - object-oriented interface
 * @export
 * @class ACLApi
 * @extends {BaseAPI}
 */
export class ACLApi extends BaseAPI {
    /**
     * 
     * @param {string} policyName The ACL policy name.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACLApi
     */
    public deleteACLPolicy(policyName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return ACLApiFp(this.configuration).deleteACLPolicy(policyName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} tokenAccessor The token accessor ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACLApi
     */
    public deleteACLToken(tokenAccessor: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return ACLApiFp(this.configuration).deleteACLToken(tokenAccessor, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACLApi
     */
    public getACLPolicies(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return ACLApiFp(this.configuration).getACLPolicies(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} policyName The ACL policy name.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACLApi
     */
    public getACLPolicy(policyName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return ACLApiFp(this.configuration).getACLPolicy(policyName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} tokenAccessor The token accessor ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACLApi
     */
    public getACLToken(tokenAccessor: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return ACLApiFp(this.configuration).getACLToken(tokenAccessor, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACLApi
     */
    public getACLTokenSelf(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return ACLApiFp(this.configuration).getACLTokenSelf(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACLApi
     */
    public getACLTokens(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return ACLApiFp(this.configuration).getACLTokens(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACLApi
     */
    public postACLBootstrap(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return ACLApiFp(this.configuration).postACLBootstrap(region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ACLPolicy} body 
     * @param {string} policyName The ACL policy name.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACLApi
     */
    public postACLPolicy(body: ACLPolicy, policyName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return ACLApiFp(this.configuration).postACLPolicy(body, policyName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ACLToken} body 
     * @param {string} tokenAccessor The token accessor ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACLApi
     */
    public postACLToken(body: ACLToken, tokenAccessor: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return ACLApiFp(this.configuration).postACLToken(body, tokenAccessor, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACLApi
     */
    public postACLTokenOnetime(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return ACLApiFp(this.configuration).postACLTokenOnetime(region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {OneTimeTokenExchangeRequest} body 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACLApi
     */
    public postACLTokenOnetimeExchange(body: OneTimeTokenExchangeRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return ACLApiFp(this.configuration).postACLTokenOnetimeExchange(body, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

}
/**
 * AllocationsApi - fetch parameter creator
 * @export
 */
export const AllocationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} allocID Allocation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocation(allocID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'allocID' is not null or undefined
            if (allocID === null || allocID === undefined) {
                throw new RequiredError('allocID','Required parameter allocID was null or undefined when calling getAllocation.');
            }
            const localVarPath = `/allocation/{allocID}`
                .replace(`{${"allocID"}}`, encodeURIComponent(String(allocID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} allocID Allocation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocationServices(allocID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'allocID' is not null or undefined
            if (allocID === null || allocID === undefined) {
                throw new RequiredError('allocID','Required parameter allocID was null or undefined when calling getAllocationServices.');
            }
            const localVarPath = `/allocation/{allocID}/services`
                .replace(`{${"allocID"}}`, encodeURIComponent(String(allocID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [resources] Flag indicating whether to include resources in response.
         * @param {boolean} [taskStates] Flag indicating whether to include task states in response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocations(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, resources?: boolean, taskStates?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/allocations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (resources !== undefined) {
                localVarQueryParameter['resources'] = resources;
            }

            if (taskStates !== undefined) {
                localVarQueryParameter['task_states'] = taskStates;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} allocID Allocation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [noShutdownDelay] Flag indicating whether to delay shutdown when requesting an allocation stop.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAllocationStop(allocID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, noShutdownDelay?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'allocID' is not null or undefined
            if (allocID === null || allocID === undefined) {
                throw new RequiredError('allocID','Required parameter allocID was null or undefined when calling postAllocationStop.');
            }
            const localVarPath = `/allocation/{allocID}/stop`
                .replace(`{${"allocID"}}`, encodeURIComponent(String(allocID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (noShutdownDelay !== undefined) {
                localVarQueryParameter['no_shutdown_delay'] = noShutdownDelay;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AllocationsApi - functional programming interface
 * @export
 */
export const AllocationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} allocID Allocation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocation(allocID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Allocation> {
            const localVarFetchArgs = AllocationsApiFetchParamCreator(configuration).getAllocation(allocID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} allocID Allocation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocationServices(allocID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ServiceRegistration>> {
            const localVarFetchArgs = AllocationsApiFetchParamCreator(configuration).getAllocationServices(allocID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [resources] Flag indicating whether to include resources in response.
         * @param {boolean} [taskStates] Flag indicating whether to include task states in response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocations(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, resources?: boolean, taskStates?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AllocationListStub>> {
            const localVarFetchArgs = AllocationsApiFetchParamCreator(configuration).getAllocations(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, resources, taskStates, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} allocID Allocation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [noShutdownDelay] Flag indicating whether to delay shutdown when requesting an allocation stop.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAllocationStop(allocID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, noShutdownDelay?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AllocStopResponse> {
            const localVarFetchArgs = AllocationsApiFetchParamCreator(configuration).postAllocationStop(allocID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, noShutdownDelay, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AllocationsApi - factory interface
 * @export
 */
export const AllocationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} allocID Allocation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocation(allocID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return AllocationsApiFp(configuration).getAllocation(allocID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} allocID Allocation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocationServices(allocID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return AllocationsApiFp(configuration).getAllocationServices(allocID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [resources] Flag indicating whether to include resources in response.
         * @param {boolean} [taskStates] Flag indicating whether to include task states in response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocations(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, resources?: boolean, taskStates?: boolean, options?: any) {
            return AllocationsApiFp(configuration).getAllocations(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, resources, taskStates, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} allocID Allocation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [noShutdownDelay] Flag indicating whether to delay shutdown when requesting an allocation stop.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAllocationStop(allocID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, noShutdownDelay?: boolean, options?: any) {
            return AllocationsApiFp(configuration).postAllocationStop(allocID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, noShutdownDelay, options)(fetch, basePath);
        },
    };
};

/**
 * AllocationsApi - object-oriented interface
 * @export
 * @class AllocationsApi
 * @extends {BaseAPI}
 */
export class AllocationsApi extends BaseAPI {
    /**
     * 
     * @param {string} allocID Allocation ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllocationsApi
     */
    public getAllocation(allocID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return AllocationsApiFp(this.configuration).getAllocation(allocID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} allocID Allocation ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllocationsApi
     */
    public getAllocationServices(allocID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return AllocationsApiFp(this.configuration).getAllocationServices(allocID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {boolean} [resources] Flag indicating whether to include resources in response.
     * @param {boolean} [taskStates] Flag indicating whether to include task states in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllocationsApi
     */
    public getAllocations(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, resources?: boolean, taskStates?: boolean, options?: any) {
        return AllocationsApiFp(this.configuration).getAllocations(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, resources, taskStates, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} allocID Allocation ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {boolean} [noShutdownDelay] Flag indicating whether to delay shutdown when requesting an allocation stop.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllocationsApi
     */
    public postAllocationStop(allocID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, noShutdownDelay?: boolean, options?: any) {
        return AllocationsApiFp(this.configuration).postAllocationStop(allocID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, noShutdownDelay, options)(this.fetch, this.basePath);
    }

}
/**
 * DeploymentsApi - fetch parameter creator
 * @export
 */
export const DeploymentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment(deploymentID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'deploymentID' is not null or undefined
            if (deploymentID === null || deploymentID === undefined) {
                throw new RequiredError('deploymentID','Required parameter deploymentID was null or undefined when calling getDeployment.');
            }
            const localVarPath = `/deployment/{deploymentID}`
                .replace(`{${"deploymentID"}}`, encodeURIComponent(String(deploymentID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentAllocations(deploymentID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'deploymentID' is not null or undefined
            if (deploymentID === null || deploymentID === undefined) {
                throw new RequiredError('deploymentID','Required parameter deploymentID was null or undefined when calling getDeploymentAllocations.');
            }
            const localVarPath = `/deployment/allocations/{deploymentID}`
                .replace(`{${"deploymentID"}}`, encodeURIComponent(String(deploymentID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployments(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/deployments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeploymentAllocHealthRequest} body 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentAllocationHealth(body: DeploymentAllocHealthRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postDeploymentAllocationHealth.');
            }
            // verify required parameter 'deploymentID' is not null or undefined
            if (deploymentID === null || deploymentID === undefined) {
                throw new RequiredError('deploymentID','Required parameter deploymentID was null or undefined when calling postDeploymentAllocationHealth.');
            }
            const localVarPath = `/deployment/allocation-health/{deploymentID}`
                .replace(`{${"deploymentID"}}`, encodeURIComponent(String(deploymentID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeploymentAllocHealthRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentFail(deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'deploymentID' is not null or undefined
            if (deploymentID === null || deploymentID === undefined) {
                throw new RequiredError('deploymentID','Required parameter deploymentID was null or undefined when calling postDeploymentFail.');
            }
            const localVarPath = `/deployment/fail/{deploymentID}`
                .replace(`{${"deploymentID"}}`, encodeURIComponent(String(deploymentID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeploymentPauseRequest} body 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentPause(body: DeploymentPauseRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postDeploymentPause.');
            }
            // verify required parameter 'deploymentID' is not null or undefined
            if (deploymentID === null || deploymentID === undefined) {
                throw new RequiredError('deploymentID','Required parameter deploymentID was null or undefined when calling postDeploymentPause.');
            }
            const localVarPath = `/deployment/pause/{deploymentID}`
                .replace(`{${"deploymentID"}}`, encodeURIComponent(String(deploymentID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeploymentPauseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeploymentPromoteRequest} body 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentPromote(body: DeploymentPromoteRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postDeploymentPromote.');
            }
            // verify required parameter 'deploymentID' is not null or undefined
            if (deploymentID === null || deploymentID === undefined) {
                throw new RequiredError('deploymentID','Required parameter deploymentID was null or undefined when calling postDeploymentPromote.');
            }
            const localVarPath = `/deployment/promote/{deploymentID}`
                .replace(`{${"deploymentID"}}`, encodeURIComponent(String(deploymentID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeploymentPromoteRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeploymentUnblockRequest} body 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentUnblock(body: DeploymentUnblockRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postDeploymentUnblock.');
            }
            // verify required parameter 'deploymentID' is not null or undefined
            if (deploymentID === null || deploymentID === undefined) {
                throw new RequiredError('deploymentID','Required parameter deploymentID was null or undefined when calling postDeploymentUnblock.');
            }
            const localVarPath = `/deployment/unblock/{deploymentID}`
                .replace(`{${"deploymentID"}}`, encodeURIComponent(String(deploymentID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeploymentUnblockRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentsApi - functional programming interface
 * @export
 */
export const DeploymentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment(deploymentID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Deployment> {
            const localVarFetchArgs = DeploymentsApiFetchParamCreator(configuration).getDeployment(deploymentID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentAllocations(deploymentID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AllocationListStub>> {
            const localVarFetchArgs = DeploymentsApiFetchParamCreator(configuration).getDeploymentAllocations(deploymentID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployments(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Deployment>> {
            const localVarFetchArgs = DeploymentsApiFetchParamCreator(configuration).getDeployments(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DeploymentAllocHealthRequest} body 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentAllocationHealth(body: DeploymentAllocHealthRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeploymentUpdateResponse> {
            const localVarFetchArgs = DeploymentsApiFetchParamCreator(configuration).postDeploymentAllocationHealth(body, deploymentID, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentFail(deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeploymentUpdateResponse> {
            const localVarFetchArgs = DeploymentsApiFetchParamCreator(configuration).postDeploymentFail(deploymentID, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DeploymentPauseRequest} body 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentPause(body: DeploymentPauseRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeploymentUpdateResponse> {
            const localVarFetchArgs = DeploymentsApiFetchParamCreator(configuration).postDeploymentPause(body, deploymentID, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DeploymentPromoteRequest} body 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentPromote(body: DeploymentPromoteRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeploymentUpdateResponse> {
            const localVarFetchArgs = DeploymentsApiFetchParamCreator(configuration).postDeploymentPromote(body, deploymentID, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {DeploymentUnblockRequest} body 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentUnblock(body: DeploymentUnblockRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeploymentUpdateResponse> {
            const localVarFetchArgs = DeploymentsApiFetchParamCreator(configuration).postDeploymentUnblock(body, deploymentID, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeploymentsApi - factory interface
 * @export
 */
export const DeploymentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment(deploymentID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return DeploymentsApiFp(configuration).getDeployment(deploymentID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentAllocations(deploymentID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return DeploymentsApiFp(configuration).getDeploymentAllocations(deploymentID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployments(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return DeploymentsApiFp(configuration).getDeployments(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DeploymentAllocHealthRequest} body 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentAllocationHealth(body: DeploymentAllocHealthRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return DeploymentsApiFp(configuration).postDeploymentAllocationHealth(body, deploymentID, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentFail(deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return DeploymentsApiFp(configuration).postDeploymentFail(deploymentID, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DeploymentPauseRequest} body 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentPause(body: DeploymentPauseRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return DeploymentsApiFp(configuration).postDeploymentPause(body, deploymentID, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DeploymentPromoteRequest} body 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentPromote(body: DeploymentPromoteRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return DeploymentsApiFp(configuration).postDeploymentPromote(body, deploymentID, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {DeploymentUnblockRequest} body 
         * @param {string} deploymentID Deployment ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeploymentUnblock(body: DeploymentUnblockRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return DeploymentsApiFp(configuration).postDeploymentUnblock(body, deploymentID, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
    };
};

/**
 * DeploymentsApi - object-oriented interface
 * @export
 * @class DeploymentsApi
 * @extends {BaseAPI}
 */
export class DeploymentsApi extends BaseAPI {
    /**
     * 
     * @param {string} deploymentID Deployment ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public getDeployment(deploymentID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return DeploymentsApiFp(this.configuration).getDeployment(deploymentID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} deploymentID Deployment ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public getDeploymentAllocations(deploymentID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return DeploymentsApiFp(this.configuration).getDeploymentAllocations(deploymentID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public getDeployments(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return DeploymentsApiFp(this.configuration).getDeployments(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DeploymentAllocHealthRequest} body 
     * @param {string} deploymentID Deployment ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public postDeploymentAllocationHealth(body: DeploymentAllocHealthRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return DeploymentsApiFp(this.configuration).postDeploymentAllocationHealth(body, deploymentID, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} deploymentID Deployment ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public postDeploymentFail(deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return DeploymentsApiFp(this.configuration).postDeploymentFail(deploymentID, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DeploymentPauseRequest} body 
     * @param {string} deploymentID Deployment ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public postDeploymentPause(body: DeploymentPauseRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return DeploymentsApiFp(this.configuration).postDeploymentPause(body, deploymentID, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DeploymentPromoteRequest} body 
     * @param {string} deploymentID Deployment ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public postDeploymentPromote(body: DeploymentPromoteRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return DeploymentsApiFp(this.configuration).postDeploymentPromote(body, deploymentID, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {DeploymentUnblockRequest} body 
     * @param {string} deploymentID Deployment ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public postDeploymentUnblock(body: DeploymentUnblockRequest, deploymentID: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return DeploymentsApiFp(this.configuration).postDeploymentUnblock(body, deploymentID, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

}
/**
 * EnterpriseApi - fetch parameter creator
 * @export
 */
export const EnterpriseApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {QuotaSpec} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuotaSpec(body: QuotaSpec, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createQuotaSpec.');
            }
            const localVarPath = `/quota`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuotaSpec" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} specName The quota spec identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuotaSpec(specName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'specName' is not null or undefined
            if (specName === null || specName === undefined) {
                throw new RequiredError('specName','Required parameter specName was null or undefined when calling deleteQuotaSpec.');
            }
            const localVarPath = `/quota/{specName}`
                .replace(`{${"specName"}}`, encodeURIComponent(String(specName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} specName The quota spec identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuotaSpec(specName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'specName' is not null or undefined
            if (specName === null || specName === undefined) {
                throw new RequiredError('specName','Required parameter specName was null or undefined when calling getQuotaSpec.');
            }
            const localVarPath = `/quota/{specName}`
                .replace(`{${"specName"}}`, encodeURIComponent(String(specName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuotas(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/quotas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QuotaSpec} body 
         * @param {string} specName The quota spec identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQuotaSpec(body: QuotaSpec, specName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postQuotaSpec.');
            }
            // verify required parameter 'specName' is not null or undefined
            if (specName === null || specName === undefined) {
                throw new RequiredError('specName','Required parameter specName was null or undefined when calling postQuotaSpec.');
            }
            const localVarPath = `/quota/{specName}`
                .replace(`{${"specName"}}`, encodeURIComponent(String(specName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuotaSpec" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnterpriseApi - functional programming interface
 * @export
 */
export const EnterpriseApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {QuotaSpec} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuotaSpec(body: QuotaSpec, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EnterpriseApiFetchParamCreator(configuration).createQuotaSpec(body, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} specName The quota spec identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuotaSpec(specName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EnterpriseApiFetchParamCreator(configuration).deleteQuotaSpec(specName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} specName The quota spec identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuotaSpec(specName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuotaSpec> {
            const localVarFetchArgs = EnterpriseApiFetchParamCreator(configuration).getQuotaSpec(specName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuotas(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = EnterpriseApiFetchParamCreator(configuration).getQuotas(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {QuotaSpec} body 
         * @param {string} specName The quota spec identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQuotaSpec(body: QuotaSpec, specName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EnterpriseApiFetchParamCreator(configuration).postQuotaSpec(body, specName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EnterpriseApi - factory interface
 * @export
 */
export const EnterpriseApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {QuotaSpec} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuotaSpec(body: QuotaSpec, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return EnterpriseApiFp(configuration).createQuotaSpec(body, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} specName The quota spec identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuotaSpec(specName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return EnterpriseApiFp(configuration).deleteQuotaSpec(specName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} specName The quota spec identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuotaSpec(specName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return EnterpriseApiFp(configuration).getQuotaSpec(specName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuotas(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return EnterpriseApiFp(configuration).getQuotas(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {QuotaSpec} body 
         * @param {string} specName The quota spec identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQuotaSpec(body: QuotaSpec, specName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return EnterpriseApiFp(configuration).postQuotaSpec(body, specName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
    };
};

/**
 * EnterpriseApi - object-oriented interface
 * @export
 * @class EnterpriseApi
 * @extends {BaseAPI}
 */
export class EnterpriseApi extends BaseAPI {
    /**
     * 
     * @param {QuotaSpec} body 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public createQuotaSpec(body: QuotaSpec, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return EnterpriseApiFp(this.configuration).createQuotaSpec(body, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} specName The quota spec identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public deleteQuotaSpec(specName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return EnterpriseApiFp(this.configuration).deleteQuotaSpec(specName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} specName The quota spec identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getQuotaSpec(specName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return EnterpriseApiFp(this.configuration).getQuotaSpec(specName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getQuotas(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return EnterpriseApiFp(this.configuration).getQuotas(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {QuotaSpec} body 
     * @param {string} specName The quota spec identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public postQuotaSpec(body: QuotaSpec, specName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return EnterpriseApiFp(this.configuration).postQuotaSpec(body, specName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

}
/**
 * EvaluationsApi - fetch parameter creator
 * @export
 */
export const EvaluationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} evalID Evaluation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluation(evalID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'evalID' is not null or undefined
            if (evalID === null || evalID === undefined) {
                throw new RequiredError('evalID','Required parameter evalID was null or undefined when calling getEvaluation.');
            }
            const localVarPath = `/evaluation/{evalID}`
                .replace(`{${"evalID"}}`, encodeURIComponent(String(evalID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} evalID Evaluation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluationAllocations(evalID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'evalID' is not null or undefined
            if (evalID === null || evalID === undefined) {
                throw new RequiredError('evalID','Required parameter evalID was null or undefined when calling getEvaluationAllocations.');
            }
            const localVarPath = `/evaluation/{evalID}/allocations`
                .replace(`{${"evalID"}}`, encodeURIComponent(String(evalID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluations(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/evaluations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EvaluationsApi - functional programming interface
 * @export
 */
export const EvaluationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} evalID Evaluation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluation(evalID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Evaluation> {
            const localVarFetchArgs = EvaluationsApiFetchParamCreator(configuration).getEvaluation(evalID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} evalID Evaluation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluationAllocations(evalID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AllocationListStub>> {
            const localVarFetchArgs = EvaluationsApiFetchParamCreator(configuration).getEvaluationAllocations(evalID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluations(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Evaluation>> {
            const localVarFetchArgs = EvaluationsApiFetchParamCreator(configuration).getEvaluations(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EvaluationsApi - factory interface
 * @export
 */
export const EvaluationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} evalID Evaluation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluation(evalID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return EvaluationsApiFp(configuration).getEvaluation(evalID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} evalID Evaluation ID.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluationAllocations(evalID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return EvaluationsApiFp(configuration).getEvaluationAllocations(evalID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluations(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return EvaluationsApiFp(configuration).getEvaluations(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
    };
};

/**
 * EvaluationsApi - object-oriented interface
 * @export
 * @class EvaluationsApi
 * @extends {BaseAPI}
 */
export class EvaluationsApi extends BaseAPI {
    /**
     * 
     * @param {string} evalID Evaluation ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsApi
     */
    public getEvaluation(evalID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return EvaluationsApiFp(this.configuration).getEvaluation(evalID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} evalID Evaluation ID.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsApi
     */
    public getEvaluationAllocations(evalID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return EvaluationsApiFp(this.configuration).getEvaluationAllocations(evalID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsApi
     */
    public getEvaluations(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return EvaluationsApiFp(this.configuration).getEvaluations(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

}
/**
 * JobsApi - fetch parameter creator
 * @export
 */
export const JobsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {boolean} [purge] Boolean flag indicating whether to purge allocations of the job after deleting.
         * @param {boolean} [global] Boolean flag indicating whether the operation should apply to all instances of the job globally.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, purge?: boolean, global?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling deleteJob.');
            }
            const localVarPath = `/job/{jobName}`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (purge !== undefined) {
                localVarQueryParameter['purge'] = purge;
            }

            if (global !== undefined) {
                localVarQueryParameter['global'] = global;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling getJob.');
            }
            const localVarPath = `/job/{jobName}`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [all] Specifies whether the list of allocations should include allocations from a previously registered job with the same ID. This is possible if the job is deregistered and reregistered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobAllocations(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, all?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling getJobAllocations.');
            }
            const localVarPath = `/job/{jobName}/allocations`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDeployment(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling getJobDeployment.');
            }
            const localVarPath = `/job/{jobName}/deployment`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {number} [all] Flag indicating whether to constrain by job creation index or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDeployments(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, all?: number, options: any = {}): FetchArgs {
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling getJobDeployments.');
            }
            const localVarPath = `/job/{jobName}/deployments`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobEvaluations(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling getJobEvaluations.');
            }
            const localVarPath = `/job/{jobName}/evaluations`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobScaleStatus(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling getJobScaleStatus.');
            }
            const localVarPath = `/job/{jobName}/scale`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobSummary(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling getJobSummary.');
            }
            const localVarPath = `/job/{jobName}/summary`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [diffs] Boolean flag indicating whether to compute job diffs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobVersions(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, diffs?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling getJobVersions.');
            }
            const localVarPath = `/job/{jobName}/versions`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (diffs !== undefined) {
                localVarQueryParameter['diffs'] = diffs;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobRegisterRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJob(body: JobRegisterRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postJob.');
            }
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling postJob.');
            }
            const localVarPath = `/job/{jobName}`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JobRegisterRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobDispatchRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDispatch(body: JobDispatchRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postJobDispatch.');
            }
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling postJobDispatch.');
            }
            const localVarPath = `/job/{jobName}/dispatch`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JobDispatchRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobEvaluateRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobEvaluate(body: JobEvaluateRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postJobEvaluate.');
            }
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling postJobEvaluate.');
            }
            const localVarPath = `/job/{jobName}/evaluate`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JobEvaluateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobsParseRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobParse(body: JobsParseRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postJobParse.');
            }
            const localVarPath = `/jobs/parse`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JobsParseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobPeriodicForce(jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling postJobPeriodicForce.');
            }
            const localVarPath = `/job/{jobName}/periodic/force`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobPlanRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobPlan(body: JobPlanRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postJobPlan.');
            }
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling postJobPlan.');
            }
            const localVarPath = `/job/{jobName}/plan`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JobPlanRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobRevertRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobRevert(body: JobRevertRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postJobRevert.');
            }
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling postJobRevert.');
            }
            const localVarPath = `/job/{jobName}/revert`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JobRevertRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ScalingRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobScalingRequest(body: ScalingRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postJobScalingRequest.');
            }
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling postJobScalingRequest.');
            }
            const localVarPath = `/job/{jobName}/scale`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScalingRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobStabilityRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobStability(body: JobStabilityRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postJobStability.');
            }
            // verify required parameter 'jobName' is not null or undefined
            if (jobName === null || jobName === undefined) {
                throw new RequiredError('jobName','Required parameter jobName was null or undefined when calling postJobStability.');
            }
            const localVarPath = `/job/{jobName}/stable`
                .replace(`{${"jobName"}}`, encodeURIComponent(String(jobName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JobStabilityRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobValidateRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobValidateRequest(body: JobValidateRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postJobValidateRequest.');
            }
            const localVarPath = `/validate/job`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JobValidateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobRegisterRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerJob(body: JobRegisterRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling registerJob.');
            }
            const localVarPath = `/jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JobRegisterRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {boolean} [purge] Boolean flag indicating whether to purge allocations of the job after deleting.
         * @param {boolean} [global] Boolean flag indicating whether the operation should apply to all instances of the job globally.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, purge?: boolean, global?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JobDeregisterResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).deleteJob(jobName, region, namespace, xNomadToken, idempotencyToken, purge, global, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Job> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).getJob(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [all] Specifies whether the list of allocations should include allocations from a previously registered job with the same ID. This is possible if the job is deregistered and reregistered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobAllocations(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, all?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AllocationListStub>> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).getJobAllocations(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, all, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDeployment(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Deployment> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).getJobDeployment(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {number} [all] Flag indicating whether to constrain by job creation index or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDeployments(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, all?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Deployment>> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).getJobDeployments(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, all, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobEvaluations(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Evaluation>> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).getJobEvaluations(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobScaleStatus(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JobScaleStatusResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).getJobScaleStatus(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobSummary(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JobSummary> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).getJobSummary(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [diffs] Boolean flag indicating whether to compute job diffs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobVersions(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, diffs?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JobVersionsResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).getJobVersions(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, diffs, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<JobListStub>> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).getJobs(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {JobRegisterRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJob(body: JobRegisterRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JobRegisterResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).postJob(body, jobName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {JobDispatchRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDispatch(body: JobDispatchRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JobDispatchResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).postJobDispatch(body, jobName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {JobEvaluateRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobEvaluate(body: JobEvaluateRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JobRegisterResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).postJobEvaluate(body, jobName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {JobsParseRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobParse(body: JobsParseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Job> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).postJobParse(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobPeriodicForce(jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PeriodicForceResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).postJobPeriodicForce(jobName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {JobPlanRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobPlan(body: JobPlanRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JobPlanResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).postJobPlan(body, jobName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {JobRevertRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobRevert(body: JobRevertRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JobRegisterResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).postJobRevert(body, jobName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ScalingRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobScalingRequest(body: ScalingRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JobRegisterResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).postJobScalingRequest(body, jobName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {JobStabilityRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobStability(body: JobStabilityRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JobStabilityResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).postJobStability(body, jobName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {JobValidateRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobValidateRequest(body: JobValidateRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JobValidateResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).postJobValidateRequest(body, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {JobRegisterRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerJob(body: JobRegisterRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JobRegisterResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).registerJob(body, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {boolean} [purge] Boolean flag indicating whether to purge allocations of the job after deleting.
         * @param {boolean} [global] Boolean flag indicating whether the operation should apply to all instances of the job globally.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, purge?: boolean, global?: boolean, options?: any) {
            return JobsApiFp(configuration).deleteJob(jobName, region, namespace, xNomadToken, idempotencyToken, purge, global, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return JobsApiFp(configuration).getJob(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [all] Specifies whether the list of allocations should include allocations from a previously registered job with the same ID. This is possible if the job is deregistered and reregistered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobAllocations(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, all?: boolean, options?: any) {
            return JobsApiFp(configuration).getJobAllocations(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, all, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDeployment(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return JobsApiFp(configuration).getJobDeployment(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {number} [all] Flag indicating whether to constrain by job creation index or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDeployments(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, all?: number, options?: any) {
            return JobsApiFp(configuration).getJobDeployments(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, all, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobEvaluations(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return JobsApiFp(configuration).getJobEvaluations(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobScaleStatus(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return JobsApiFp(configuration).getJobScaleStatus(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobSummary(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return JobsApiFp(configuration).getJobSummary(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [diffs] Boolean flag indicating whether to compute job diffs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobVersions(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, diffs?: boolean, options?: any) {
            return JobsApiFp(configuration).getJobVersions(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, diffs, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return JobsApiFp(configuration).getJobs(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {JobRegisterRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJob(body: JobRegisterRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return JobsApiFp(configuration).postJob(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {JobDispatchRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDispatch(body: JobDispatchRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return JobsApiFp(configuration).postJobDispatch(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {JobEvaluateRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobEvaluate(body: JobEvaluateRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return JobsApiFp(configuration).postJobEvaluate(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {JobsParseRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobParse(body: JobsParseRequest, options?: any) {
            return JobsApiFp(configuration).postJobParse(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobPeriodicForce(jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return JobsApiFp(configuration).postJobPeriodicForce(jobName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {JobPlanRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobPlan(body: JobPlanRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return JobsApiFp(configuration).postJobPlan(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {JobRevertRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobRevert(body: JobRevertRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return JobsApiFp(configuration).postJobRevert(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ScalingRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobScalingRequest(body: ScalingRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return JobsApiFp(configuration).postJobScalingRequest(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {JobStabilityRequest} body 
         * @param {string} jobName The job identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobStability(body: JobStabilityRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return JobsApiFp(configuration).postJobStability(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {JobValidateRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobValidateRequest(body: JobValidateRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return JobsApiFp(configuration).postJobValidateRequest(body, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {JobRegisterRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerJob(body: JobRegisterRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return JobsApiFp(configuration).registerJob(body, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {boolean} [purge] Boolean flag indicating whether to purge allocations of the job after deleting.
     * @param {boolean} [global] Boolean flag indicating whether the operation should apply to all instances of the job globally.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public deleteJob(jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, purge?: boolean, global?: boolean, options?: any) {
        return JobsApiFp(this.configuration).deleteJob(jobName, region, namespace, xNomadToken, idempotencyToken, purge, global, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJob(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return JobsApiFp(this.configuration).getJob(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {boolean} [all] Specifies whether the list of allocations should include allocations from a previously registered job with the same ID. This is possible if the job is deregistered and reregistered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobAllocations(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, all?: boolean, options?: any) {
        return JobsApiFp(this.configuration).getJobAllocations(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, all, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobDeployment(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return JobsApiFp(this.configuration).getJobDeployment(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {number} [all] Flag indicating whether to constrain by job creation index or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobDeployments(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, all?: number, options?: any) {
        return JobsApiFp(this.configuration).getJobDeployments(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, all, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobEvaluations(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return JobsApiFp(this.configuration).getJobEvaluations(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobScaleStatus(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return JobsApiFp(this.configuration).getJobScaleStatus(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobSummary(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return JobsApiFp(this.configuration).getJobSummary(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {boolean} [diffs] Boolean flag indicating whether to compute job diffs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobVersions(jobName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, diffs?: boolean, options?: any) {
        return JobsApiFp(this.configuration).getJobVersions(jobName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, diffs, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobs(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return JobsApiFp(this.configuration).getJobs(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {JobRegisterRequest} body 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJob(body: JobRegisterRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return JobsApiFp(this.configuration).postJob(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {JobDispatchRequest} body 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobDispatch(body: JobDispatchRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return JobsApiFp(this.configuration).postJobDispatch(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {JobEvaluateRequest} body 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobEvaluate(body: JobEvaluateRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return JobsApiFp(this.configuration).postJobEvaluate(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {JobsParseRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobParse(body: JobsParseRequest, options?: any) {
        return JobsApiFp(this.configuration).postJobParse(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobPeriodicForce(jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return JobsApiFp(this.configuration).postJobPeriodicForce(jobName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {JobPlanRequest} body 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobPlan(body: JobPlanRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return JobsApiFp(this.configuration).postJobPlan(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {JobRevertRequest} body 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobRevert(body: JobRevertRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return JobsApiFp(this.configuration).postJobRevert(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ScalingRequest} body 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobScalingRequest(body: ScalingRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return JobsApiFp(this.configuration).postJobScalingRequest(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {JobStabilityRequest} body 
     * @param {string} jobName The job identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobStability(body: JobStabilityRequest, jobName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return JobsApiFp(this.configuration).postJobStability(body, jobName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {JobValidateRequest} body 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobValidateRequest(body: JobValidateRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return JobsApiFp(this.configuration).postJobValidateRequest(body, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {JobRegisterRequest} body 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public registerJob(body: JobRegisterRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return JobsApiFp(this.configuration).registerJob(body, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

}
/**
 * MetricsApi - fetch parameter creator
 * @export
 */
export const MetricsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [format] The format the user requested for the metrics summary (e.g. prometheus)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsSummary(format?: string, options: any = {}): FetchArgs {
            const localVarPath = `/metrics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [format] The format the user requested for the metrics summary (e.g. prometheus)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsSummary(format?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MetricsSummary> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).getMetricsSummary(format, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [format] The format the user requested for the metrics summary (e.g. prometheus)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsSummary(format?: string, options?: any) {
            return MetricsApiFp(configuration).getMetricsSummary(format, options)(fetch, basePath);
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * 
     * @param {string} [format] The format the user requested for the metrics summary (e.g. prometheus)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetricsSummary(format?: string, options?: any) {
        return MetricsApiFp(this.configuration).getMetricsSummary(format, options)(this.fetch, this.basePath);
    }

}
/**
 * NamespacesApi - fetch parameter creator
 * @export
 */
export const NamespacesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/namespace`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespaceName The namespace identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace(namespaceName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespaceName' is not null or undefined
            if (namespaceName === null || namespaceName === undefined) {
                throw new RequiredError('namespaceName','Required parameter namespaceName was null or undefined when calling deleteNamespace.');
            }
            const localVarPath = `/namespace/{namespaceName}`
                .replace(`{${"namespaceName"}}`, encodeURIComponent(String(namespaceName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespaceName The namespace identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace(namespaceName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespaceName' is not null or undefined
            if (namespaceName === null || namespaceName === undefined) {
                throw new RequiredError('namespaceName','Required parameter namespaceName was null or undefined when calling getNamespace.');
            }
            const localVarPath = `/namespace/{namespaceName}`
                .replace(`{${"namespaceName"}}`, encodeURIComponent(String(namespaceName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/namespaces`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Namespace} body 
         * @param {string} namespaceName The namespace identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNamespace(body: Namespace, namespaceName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postNamespace.');
            }
            // verify required parameter 'namespaceName' is not null or undefined
            if (namespaceName === null || namespaceName === undefined) {
                throw new RequiredError('namespaceName','Required parameter namespaceName was null or undefined when calling postNamespace.');
            }
            const localVarPath = `/namespace/{namespaceName}`
                .replace(`{${"namespaceName"}}`, encodeURIComponent(String(namespaceName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Namespace" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NamespacesApi - functional programming interface
 * @export
 */
export const NamespacesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).createNamespace(region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} namespaceName The namespace identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace(namespaceName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).deleteNamespace(namespaceName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} namespaceName The namespace identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace(namespaceName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Namespace> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getNamespace(namespaceName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Namespace>> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getNamespaces(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Namespace} body 
         * @param {string} namespaceName The namespace identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNamespace(body: Namespace, namespaceName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).postNamespace(body, namespaceName, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NamespacesApi - factory interface
 * @export
 */
export const NamespacesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return NamespacesApiFp(configuration).createNamespace(region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} namespaceName The namespace identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace(namespaceName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return NamespacesApiFp(configuration).deleteNamespace(namespaceName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} namespaceName The namespace identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace(namespaceName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return NamespacesApiFp(configuration).getNamespace(namespaceName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaces(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return NamespacesApiFp(configuration).getNamespaces(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Namespace} body 
         * @param {string} namespaceName The namespace identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNamespace(body: Namespace, namespaceName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return NamespacesApiFp(configuration).postNamespace(body, namespaceName, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
    };
};

/**
 * NamespacesApi - object-oriented interface
 * @export
 * @class NamespacesApi
 * @extends {BaseAPI}
 */
export class NamespacesApi extends BaseAPI {
    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public createNamespace(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return NamespacesApiFp(this.configuration).createNamespace(region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} namespaceName The namespace identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteNamespace(namespaceName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return NamespacesApiFp(this.configuration).deleteNamespace(namespaceName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} namespaceName The namespace identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespace(namespaceName: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return NamespacesApiFp(this.configuration).getNamespace(namespaceName, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaces(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return NamespacesApiFp(this.configuration).getNamespaces(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Namespace} body 
     * @param {string} namespaceName The namespace identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public postNamespace(body: Namespace, namespaceName: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return NamespacesApiFp(this.configuration).postNamespace(body, namespaceName, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

}
/**
 * NodesApi - fetch parameter creator
 * @export
 */
export const NodesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode(nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling getNode.');
            }
            const localVarPath = `/node/{nodeId}`
                .replace(`{${"nodeId"}}`, encodeURIComponent(String(nodeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeAllocations(nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling getNodeAllocations.');
            }
            const localVarPath = `/node/{nodeId}/allocations`
                .replace(`{${"nodeId"}}`, encodeURIComponent(String(nodeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [resources] Whether or not to include the NodeResources and ReservedResources fields in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, resources?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/nodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (resources !== undefined) {
                localVarQueryParameter['resources'] = resources;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NodeUpdateDrainRequest} body 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeDrain(body: NodeUpdateDrainRequest, nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateNodeDrain.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling updateNodeDrain.');
            }
            const localVarPath = `/node/{nodeId}/drain`
                .replace(`{${"nodeId"}}`, encodeURIComponent(String(nodeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NodeUpdateDrainRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NodeUpdateEligibilityRequest} body 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeEligibility(body: NodeUpdateEligibilityRequest, nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateNodeEligibility.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling updateNodeEligibility.');
            }
            const localVarPath = `/node/{nodeId}/eligibility`
                .replace(`{${"nodeId"}}`, encodeURIComponent(String(nodeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NodeUpdateEligibilityRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodePurge(nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling updateNodePurge.');
            }
            const localVarPath = `/node/{nodeId}/purge`
                .replace(`{${"nodeId"}}`, encodeURIComponent(String(nodeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesApi - functional programming interface
 * @export
 */
export const NodesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode(nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Node> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).getNode(nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeAllocations(nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AllocationListStub>> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).getNodeAllocations(nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [resources] Whether or not to include the NodeResources and ReservedResources fields in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, resources?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NodeListStub>> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).getNodes(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, resources, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {NodeUpdateDrainRequest} body 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeDrain(body: NodeUpdateDrainRequest, nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NodeDrainUpdateResponse> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).updateNodeDrain(body, nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {NodeUpdateEligibilityRequest} body 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeEligibility(body: NodeUpdateEligibilityRequest, nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NodeEligibilityUpdateResponse> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).updateNodeEligibility(body, nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodePurge(nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NodePurgeResponse> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).updateNodePurge(nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NodesApi - factory interface
 * @export
 */
export const NodesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode(nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return NodesApiFp(configuration).getNode(nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeAllocations(nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return NodesApiFp(configuration).getNodeAllocations(nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {boolean} [resources] Whether or not to include the NodeResources and ReservedResources fields in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, resources?: boolean, options?: any) {
            return NodesApiFp(configuration).getNodes(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, resources, options)(fetch, basePath);
        },
        /**
         * 
         * @param {NodeUpdateDrainRequest} body 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeDrain(body: NodeUpdateDrainRequest, nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return NodesApiFp(configuration).updateNodeDrain(body, nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {NodeUpdateEligibilityRequest} body 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeEligibility(body: NodeUpdateEligibilityRequest, nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return NodesApiFp(configuration).updateNodeEligibility(body, nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} nodeId The ID of the node.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodePurge(nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return NodesApiFp(configuration).updateNodePurge(nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
    };
};

/**
 * NodesApi - object-oriented interface
 * @export
 * @class NodesApi
 * @extends {BaseAPI}
 */
export class NodesApi extends BaseAPI {
    /**
     * 
     * @param {string} nodeId The ID of the node.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getNode(nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return NodesApiFp(this.configuration).getNode(nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} nodeId The ID of the node.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getNodeAllocations(nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return NodesApiFp(this.configuration).getNodeAllocations(nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {boolean} [resources] Whether or not to include the NodeResources and ReservedResources fields in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getNodes(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, resources?: boolean, options?: any) {
        return NodesApiFp(this.configuration).getNodes(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, resources, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {NodeUpdateDrainRequest} body 
     * @param {string} nodeId The ID of the node.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public updateNodeDrain(body: NodeUpdateDrainRequest, nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return NodesApiFp(this.configuration).updateNodeDrain(body, nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {NodeUpdateEligibilityRequest} body 
     * @param {string} nodeId The ID of the node.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public updateNodeEligibility(body: NodeUpdateEligibilityRequest, nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return NodesApiFp(this.configuration).updateNodeEligibility(body, nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} nodeId The ID of the node.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public updateNodePurge(nodeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return NodesApiFp(this.configuration).updateNodePurge(nodeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

}
/**
 * OperatorApi - fetch parameter creator
 * @export
 */
export const OperatorApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperatorRaftPeer(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/operator/raft/peer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorAutopilotConfiguration(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/operator/autopilot/configuration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorAutopilotHealth(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/operator/autopilot/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorRaftConfiguration(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/operator/raft/configuration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorSchedulerConfiguration(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/operator/scheduler/configuration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SchedulerConfiguration} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOperatorSchedulerConfiguration(body: SchedulerConfiguration, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postOperatorSchedulerConfiguration.');
            }
            const localVarPath = `/operator/scheduler/configuration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SchedulerConfiguration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AutopilotConfiguration} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOperatorAutopilotConfiguration(body: AutopilotConfiguration, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putOperatorAutopilotConfiguration.');
            }
            const localVarPath = `/operator/autopilot/configuration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AutopilotConfiguration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperatorApi - functional programming interface
 * @export
 */
export const OperatorApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperatorRaftPeer(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OperatorApiFetchParamCreator(configuration).deleteOperatorRaftPeer(region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorAutopilotConfiguration(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutopilotConfiguration> {
            const localVarFetchArgs = OperatorApiFetchParamCreator(configuration).getOperatorAutopilotConfiguration(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorAutopilotHealth(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperatorHealthReply> {
            const localVarFetchArgs = OperatorApiFetchParamCreator(configuration).getOperatorAutopilotHealth(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorRaftConfiguration(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RaftConfiguration> {
            const localVarFetchArgs = OperatorApiFetchParamCreator(configuration).getOperatorRaftConfiguration(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorSchedulerConfiguration(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SchedulerConfigurationResponse> {
            const localVarFetchArgs = OperatorApiFetchParamCreator(configuration).getOperatorSchedulerConfiguration(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SchedulerConfiguration} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOperatorSchedulerConfiguration(body: SchedulerConfiguration, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SchedulerSetConfigurationResponse> {
            const localVarFetchArgs = OperatorApiFetchParamCreator(configuration).postOperatorSchedulerConfiguration(body, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AutopilotConfiguration} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOperatorAutopilotConfiguration(body: AutopilotConfiguration, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = OperatorApiFetchParamCreator(configuration).putOperatorAutopilotConfiguration(body, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OperatorApi - factory interface
 * @export
 */
export const OperatorApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperatorRaftPeer(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return OperatorApiFp(configuration).deleteOperatorRaftPeer(region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorAutopilotConfiguration(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return OperatorApiFp(configuration).getOperatorAutopilotConfiguration(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorAutopilotHealth(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return OperatorApiFp(configuration).getOperatorAutopilotHealth(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorRaftConfiguration(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return OperatorApiFp(configuration).getOperatorRaftConfiguration(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperatorSchedulerConfiguration(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return OperatorApiFp(configuration).getOperatorSchedulerConfiguration(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SchedulerConfiguration} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOperatorSchedulerConfiguration(body: SchedulerConfiguration, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return OperatorApiFp(configuration).postOperatorSchedulerConfiguration(body, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AutopilotConfiguration} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOperatorAutopilotConfiguration(body: AutopilotConfiguration, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return OperatorApiFp(configuration).putOperatorAutopilotConfiguration(body, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
    };
};

/**
 * OperatorApi - object-oriented interface
 * @export
 * @class OperatorApi
 * @extends {BaseAPI}
 */
export class OperatorApi extends BaseAPI {
    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public deleteOperatorRaftPeer(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return OperatorApiFp(this.configuration).deleteOperatorRaftPeer(region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public getOperatorAutopilotConfiguration(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return OperatorApiFp(this.configuration).getOperatorAutopilotConfiguration(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public getOperatorAutopilotHealth(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return OperatorApiFp(this.configuration).getOperatorAutopilotHealth(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public getOperatorRaftConfiguration(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return OperatorApiFp(this.configuration).getOperatorRaftConfiguration(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public getOperatorSchedulerConfiguration(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return OperatorApiFp(this.configuration).getOperatorSchedulerConfiguration(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SchedulerConfiguration} body 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public postOperatorSchedulerConfiguration(body: SchedulerConfiguration, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return OperatorApiFp(this.configuration).postOperatorSchedulerConfiguration(body, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AutopilotConfiguration} body 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorApi
     */
    public putOperatorAutopilotConfiguration(body: AutopilotConfiguration, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return OperatorApiFp(this.configuration).putOperatorAutopilotConfiguration(body, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

}
/**
 * PluginsApi - fetch parameter creator
 * @export
 */
export const PluginsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} pluginID The CSI plugin identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginCSI(pluginID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pluginID' is not null or undefined
            if (pluginID === null || pluginID === undefined) {
                throw new RequiredError('pluginID','Required parameter pluginID was null or undefined when calling getPluginCSI.');
            }
            const localVarPath = `/plugin/csi/{pluginID}`
                .replace(`{${"pluginID"}}`, encodeURIComponent(String(pluginID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlugins(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/plugins`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginsApi - functional programming interface
 * @export
 */
export const PluginsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} pluginID The CSI plugin identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginCSI(pluginID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CSIPlugin>> {
            const localVarFetchArgs = PluginsApiFetchParamCreator(configuration).getPluginCSI(pluginID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlugins(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CSIPluginListStub>> {
            const localVarFetchArgs = PluginsApiFetchParamCreator(configuration).getPlugins(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PluginsApi - factory interface
 * @export
 */
export const PluginsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} pluginID The CSI plugin identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginCSI(pluginID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return PluginsApiFp(configuration).getPluginCSI(pluginID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlugins(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return PluginsApiFp(configuration).getPlugins(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
    };
};

/**
 * PluginsApi - object-oriented interface
 * @export
 * @class PluginsApi
 * @extends {BaseAPI}
 */
export class PluginsApi extends BaseAPI {
    /**
     * 
     * @param {string} pluginID The CSI plugin identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getPluginCSI(pluginID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return PluginsApiFp(this.configuration).getPluginCSI(pluginID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getPlugins(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return PluginsApiFp(this.configuration).getPlugins(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

}
/**
 * RegionsApi - fetch parameter creator
 * @export
 */
export const RegionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions(options: any = {}): FetchArgs {
            const localVarPath = `/regions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegionsApi - functional programming interface
 * @export
 */
export const RegionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = RegionsApiFetchParamCreator(configuration).getRegions(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RegionsApi - factory interface
 * @export
 */
export const RegionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions(options?: any) {
            return RegionsApiFp(configuration).getRegions(options)(fetch, basePath);
        },
    };
};

/**
 * RegionsApi - object-oriented interface
 * @export
 * @class RegionsApi
 * @extends {BaseAPI}
 */
export class RegionsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public getRegions(options?: any) {
        return RegionsApiFp(this.configuration).getRegions(options)(this.fetch, this.basePath);
    }

}
/**
 * ScalingApi - fetch parameter creator
 * @export
 */
export const ScalingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalingPolicies(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/scaling/policies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyID The scaling policy identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalingPolicy(policyID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'policyID' is not null or undefined
            if (policyID === null || policyID === undefined) {
                throw new RequiredError('policyID','Required parameter policyID was null or undefined when calling getScalingPolicy.');
            }
            const localVarPath = `/scaling/policy/{policyID}`
                .replace(`{${"policyID"}}`, encodeURIComponent(String(policyID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScalingApi - functional programming interface
 * @export
 */
export const ScalingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalingPolicies(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ScalingPolicyListStub>> {
            const localVarFetchArgs = ScalingApiFetchParamCreator(configuration).getScalingPolicies(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} policyID The scaling policy identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalingPolicy(policyID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScalingPolicy> {
            const localVarFetchArgs = ScalingApiFetchParamCreator(configuration).getScalingPolicy(policyID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ScalingApi - factory interface
 * @export
 */
export const ScalingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalingPolicies(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return ScalingApiFp(configuration).getScalingPolicies(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} policyID The scaling policy identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalingPolicy(policyID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return ScalingApiFp(configuration).getScalingPolicy(policyID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
    };
};

/**
 * ScalingApi - object-oriented interface
 * @export
 * @class ScalingApi
 * @extends {BaseAPI}
 */
export class ScalingApi extends BaseAPI {
    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalingApi
     */
    public getScalingPolicies(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return ScalingApiFp(this.configuration).getScalingPolicies(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} policyID The scaling policy identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalingApi
     */
    public getScalingPolicy(policyID: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return ScalingApiFp(this.configuration).getScalingPolicy(policyID, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

}
/**
 * SearchApi - fetch parameter creator
 * @export
 */
export const SearchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FuzzySearchRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuzzySearch(body: FuzzySearchRequest, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getFuzzySearch.');
            }
            const localVarPath = `/search/fuzzy`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FuzzySearchRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(body: SearchRequest, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getSearch.');
            }
            const localVarPath = `/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SearchRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FuzzySearchRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuzzySearch(body: FuzzySearchRequest, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FuzzySearchResponse> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).getFuzzySearch(body, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SearchRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(body: SearchRequest, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchResponse> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).getSearch(body, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {FuzzySearchRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuzzySearch(body: FuzzySearchRequest, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return SearchApiFp(configuration).getFuzzySearch(body, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SearchRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(body: SearchRequest, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return SearchApiFp(configuration).getSearch(body, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @param {FuzzySearchRequest} body 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getFuzzySearch(body: FuzzySearchRequest, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return SearchApiFp(this.configuration).getFuzzySearch(body, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SearchRequest} body 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getSearch(body: SearchRequest, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return SearchApiFp(this.configuration).getSearch(body, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

}
/**
 * StatusApi - fetch parameter creator
 * @export
 */
export const StatusApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusLeader(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/status/leader`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusPeers(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/status/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusLeader(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = StatusApiFetchParamCreator(configuration).getStatusLeader(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusPeers(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = StatusApiFetchParamCreator(configuration).getStatusPeers(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusLeader(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return StatusApiFp(configuration).getStatusLeader(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusPeers(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return StatusApiFp(configuration).getStatusPeers(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public getStatusLeader(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return StatusApiFp(this.configuration).getStatusLeader(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public getStatusPeers(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return StatusApiFp(this.configuration).getStatusPeers(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

}
/**
 * SystemApi - fetch parameter creator
 * @export
 */
export const SystemApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSystemGC(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/system/gc`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSystemReconcileSummaries(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/system/reconcile/summaries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSystemGC(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SystemApiFetchParamCreator(configuration).putSystemGC(region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSystemReconcileSummaries(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SystemApiFetchParamCreator(configuration).putSystemReconcileSummaries(region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSystemGC(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return SystemApiFp(configuration).putSystemGC(region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSystemReconcileSummaries(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return SystemApiFp(configuration).putSystemReconcileSummaries(region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public putSystemGC(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return SystemApiFp(this.configuration).putSystemGC(region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public putSystemReconcileSummaries(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return SystemApiFp(this.configuration).putSystemReconcileSummaries(region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

}
/**
 * VariablesApi - fetch parameter creator
 * @export
 */
export const VariablesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Variable} body 
         * @param {string} path A path to a Nomad Variable
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {number} [cas] A compare-and-set parameter for Nomad Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariable(body: Variable, path: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, cas?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteVariable.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling deleteVariable.');
            }
            const localVarPath = `/var/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (cas !== undefined) {
                localVarQueryParameter['cas'] = cas;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Variable" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} path A path to a Nomad Variable
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableQuery(path: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getVariableQuery.');
            }
            const localVarPath = `/var/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariablesListRequest(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/vars`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Variable} body 
         * @param {string} path A path to a Nomad Variable
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {number} [cas] A compare-and-set parameter for Nomad Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVariable(body: Variable, path: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, cas?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postVariable.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postVariable.');
            }
            const localVarPath = `/var/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (cas !== undefined) {
                localVarQueryParameter['cas'] = cas;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Variable" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Variable} body 
         * @param {string} path A path to a Nomad Variable
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {number} [cas] A compare-and-set parameter for Nomad Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVariable(body: Variable, path: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, cas?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putVariable.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling putVariable.');
            }
            const localVarPath = `/var/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (cas !== undefined) {
                localVarQueryParameter['cas'] = cas;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Variable" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariablesApi - functional programming interface
 * @export
 */
export const VariablesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Variable} body 
         * @param {string} path A path to a Nomad Variable
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {number} [cas] A compare-and-set parameter for Nomad Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariable(body: Variable, path: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, cas?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VariablesApiFetchParamCreator(configuration).deleteVariable(body, path, region, namespace, xNomadToken, idempotencyToken, cas, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} path A path to a Nomad Variable
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableQuery(path: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Variable> {
            const localVarFetchArgs = VariablesApiFetchParamCreator(configuration).getVariableQuery(path, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariablesListRequest(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<VariableMetadata>> {
            const localVarFetchArgs = VariablesApiFetchParamCreator(configuration).getVariablesListRequest(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Variable} body 
         * @param {string} path A path to a Nomad Variable
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {number} [cas] A compare-and-set parameter for Nomad Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVariable(body: Variable, path: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, cas?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Variable> {
            const localVarFetchArgs = VariablesApiFetchParamCreator(configuration).postVariable(body, path, region, namespace, xNomadToken, idempotencyToken, cas, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Variable} body 
         * @param {string} path A path to a Nomad Variable
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {number} [cas] A compare-and-set parameter for Nomad Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVariable(body: Variable, path: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, cas?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Variable> {
            const localVarFetchArgs = VariablesApiFetchParamCreator(configuration).putVariable(body, path, region, namespace, xNomadToken, idempotencyToken, cas, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VariablesApi - factory interface
 * @export
 */
export const VariablesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Variable} body 
         * @param {string} path A path to a Nomad Variable
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {number} [cas] A compare-and-set parameter for Nomad Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariable(body: Variable, path: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, cas?: number, options?: any) {
            return VariablesApiFp(configuration).deleteVariable(body, path, region, namespace, xNomadToken, idempotencyToken, cas, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} path A path to a Nomad Variable
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableQuery(path: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return VariablesApiFp(configuration).getVariableQuery(path, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariablesListRequest(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return VariablesApiFp(configuration).getVariablesListRequest(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Variable} body 
         * @param {string} path A path to a Nomad Variable
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {number} [cas] A compare-and-set parameter for Nomad Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVariable(body: Variable, path: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, cas?: number, options?: any) {
            return VariablesApiFp(configuration).postVariable(body, path, region, namespace, xNomadToken, idempotencyToken, cas, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Variable} body 
         * @param {string} path A path to a Nomad Variable
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {number} [cas] A compare-and-set parameter for Nomad Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVariable(body: Variable, path: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, cas?: number, options?: any) {
            return VariablesApiFp(configuration).putVariable(body, path, region, namespace, xNomadToken, idempotencyToken, cas, options)(fetch, basePath);
        },
    };
};

/**
 * VariablesApi - object-oriented interface
 * @export
 * @class VariablesApi
 * @extends {BaseAPI}
 */
export class VariablesApi extends BaseAPI {
    /**
     * 
     * @param {Variable} body 
     * @param {string} path A path to a Nomad Variable
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {number} [cas] A compare-and-set parameter for Nomad Variables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public deleteVariable(body: Variable, path: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, cas?: number, options?: any) {
        return VariablesApiFp(this.configuration).deleteVariable(body, path, region, namespace, xNomadToken, idempotencyToken, cas, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} path A path to a Nomad Variable
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariableQuery(path: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return VariablesApiFp(this.configuration).getVariableQuery(path, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariablesListRequest(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return VariablesApiFp(this.configuration).getVariablesListRequest(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Variable} body 
     * @param {string} path A path to a Nomad Variable
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {number} [cas] A compare-and-set parameter for Nomad Variables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public postVariable(body: Variable, path: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, cas?: number, options?: any) {
        return VariablesApiFp(this.configuration).postVariable(body, path, region, namespace, xNomadToken, idempotencyToken, cas, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Variable} body 
     * @param {string} path A path to a Nomad Variable
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {number} [cas] A compare-and-set parameter for Nomad Variables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public putVariable(body: Variable, path: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, cas?: number, options?: any) {
        return VariablesApiFp(this.configuration).putVariable(body, path, region, namespace, xNomadToken, idempotencyToken, cas, options)(this.fetch, this.basePath);
    }

}
/**
 * VolumesApi - fetch parameter creator
 * @export
 */
export const VolumesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CSIVolumeCreateRequest} body 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} action The action to perform on the Volume (create, detach, delete).
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolume(body: CSIVolumeCreateRequest, volumeId: string, action: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createVolume.');
            }
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling createVolume.');
            }
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling createVolume.');
            }
            const localVarPath = `/volume/csi/{volumeId}/{action}`
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)))
                .replace(`{${"action"}}`, encodeURIComponent(String(action)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CSIVolumeCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {string} [pluginId] Filters volume lists by plugin ID.
         * @param {string} [snapshotId] The ID of the snapshot to target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, pluginId?: string, snapshotId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/volumes/snapshot`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (pluginId !== undefined) {
                localVarQueryParameter['plugin_id'] = pluginId;
            }

            if (snapshotId !== undefined) {
                localVarQueryParameter['snapshot_id'] = snapshotId;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {string} [force] Used to force the de-registration of a volume.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolumeRegistration(volumeId: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, force?: string, options: any = {}): FetchArgs {
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling deleteVolumeRegistration.');
            }
            const localVarPath = `/volume/csi/{volumeId}`
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} action The action to perform on the Volume (create, detach, delete).
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {string} [node] Specifies node to target volume operation for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachOrDeleteVolume(volumeId: string, action: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, node?: string, options: any = {}): FetchArgs {
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling detachOrDeleteVolume.');
            }
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling detachOrDeleteVolume.');
            }
            const localVarPath = `/volume/csi/{volumeId}/{action}`
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)))
                .replace(`{${"action"}}`, encodeURIComponent(String(action)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (node !== undefined) {
                localVarQueryParameter['node'] = node;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {string} [pluginId] Filters volume lists by plugin ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalVolumes(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, pluginId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/volumes/external`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (pluginId !== undefined) {
                localVarQueryParameter['plugin_id'] = pluginId;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {string} [pluginId] Filters volume lists by plugin ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshots(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, pluginId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/volumes/snapshot`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (pluginId !== undefined) {
                localVarQueryParameter['plugin_id'] = pluginId;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolume(volumeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling getVolume.');
            }
            const localVarPath = `/volume/csi/{volumeId}`
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {string} [nodeId] Filters volume lists by node ID.
         * @param {string} [pluginId] Filters volume lists by plugin ID.
         * @param {string} [type] Filters volume lists to a specific type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolumes(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, nodeId?: string, pluginId?: string, type?: string, options: any = {}): FetchArgs {
            const localVarPath = `/volumes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (nodeId !== undefined) {
                localVarQueryParameter['node_id'] = nodeId;
            }

            if (pluginId !== undefined) {
                localVarQueryParameter['plugin_id'] = pluginId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (index !== undefined && index !== null) {
                localVarHeaderParameter['index'] = String(index);
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CSISnapshotCreateRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSnapshot(body: CSISnapshotCreateRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSnapshot.');
            }
            const localVarPath = `/volumes/snapshot`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CSISnapshotCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CSIVolumeRegisterRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVolume(body: CSIVolumeRegisterRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postVolume.');
            }
            const localVarPath = `/volumes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CSIVolumeRegisterRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CSIVolumeRegisterRequest} body 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVolumeRegistration(body: CSIVolumeRegisterRequest, volumeId: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postVolumeRegistration.');
            }
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling postVolumeRegistration.');
            }
            const localVarPath = `/volume/csi/{volumeId}`
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Nomad-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Nomad-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Nomad-Token"] = localVarApiKeyValue;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (idempotencyToken !== undefined) {
                localVarQueryParameter['idempotency_token'] = idempotencyToken;
            }

            if (xNomadToken !== undefined && xNomadToken !== null) {
                localVarHeaderParameter['X-Nomad-Token'] = String(xNomadToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CSIVolumeRegisterRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VolumesApi - functional programming interface
 * @export
 */
export const VolumesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CSIVolumeCreateRequest} body 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} action The action to perform on the Volume (create, detach, delete).
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolume(body: CSIVolumeCreateRequest, volumeId: string, action: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VolumesApiFetchParamCreator(configuration).createVolume(body, volumeId, action, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {string} [pluginId] Filters volume lists by plugin ID.
         * @param {string} [snapshotId] The ID of the snapshot to target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, pluginId?: string, snapshotId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VolumesApiFetchParamCreator(configuration).deleteSnapshot(region, namespace, xNomadToken, idempotencyToken, pluginId, snapshotId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {string} [force] Used to force the de-registration of a volume.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolumeRegistration(volumeId: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, force?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VolumesApiFetchParamCreator(configuration).deleteVolumeRegistration(volumeId, region, namespace, xNomadToken, idempotencyToken, force, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} action The action to perform on the Volume (create, detach, delete).
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {string} [node] Specifies node to target volume operation for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachOrDeleteVolume(volumeId: string, action: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, node?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VolumesApiFetchParamCreator(configuration).detachOrDeleteVolume(volumeId, action, region, namespace, xNomadToken, idempotencyToken, node, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {string} [pluginId] Filters volume lists by plugin ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalVolumes(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, pluginId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CSIVolumeListExternalResponse> {
            const localVarFetchArgs = VolumesApiFetchParamCreator(configuration).getExternalVolumes(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, pluginId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {string} [pluginId] Filters volume lists by plugin ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshots(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, pluginId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CSISnapshotListResponse> {
            const localVarFetchArgs = VolumesApiFetchParamCreator(configuration).getSnapshots(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, pluginId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolume(volumeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CSIVolume> {
            const localVarFetchArgs = VolumesApiFetchParamCreator(configuration).getVolume(volumeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {string} [nodeId] Filters volume lists by node ID.
         * @param {string} [pluginId] Filters volume lists by plugin ID.
         * @param {string} [type] Filters volume lists to a specific type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolumes(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, nodeId?: string, pluginId?: string, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CSIVolumeListStub>> {
            const localVarFetchArgs = VolumesApiFetchParamCreator(configuration).getVolumes(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, nodeId, pluginId, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CSISnapshotCreateRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSnapshot(body: CSISnapshotCreateRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CSISnapshotCreateResponse> {
            const localVarFetchArgs = VolumesApiFetchParamCreator(configuration).postSnapshot(body, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CSIVolumeRegisterRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVolume(body: CSIVolumeRegisterRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VolumesApiFetchParamCreator(configuration).postVolume(body, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CSIVolumeRegisterRequest} body 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVolumeRegistration(body: CSIVolumeRegisterRequest, volumeId: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VolumesApiFetchParamCreator(configuration).postVolumeRegistration(body, volumeId, region, namespace, xNomadToken, idempotencyToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VolumesApi - factory interface
 * @export
 */
export const VolumesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CSIVolumeCreateRequest} body 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} action The action to perform on the Volume (create, detach, delete).
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolume(body: CSIVolumeCreateRequest, volumeId: string, action: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return VolumesApiFp(configuration).createVolume(body, volumeId, action, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {string} [pluginId] Filters volume lists by plugin ID.
         * @param {string} [snapshotId] The ID of the snapshot to target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, pluginId?: string, snapshotId?: string, options?: any) {
            return VolumesApiFp(configuration).deleteSnapshot(region, namespace, xNomadToken, idempotencyToken, pluginId, snapshotId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {string} [force] Used to force the de-registration of a volume.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolumeRegistration(volumeId: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, force?: string, options?: any) {
            return VolumesApiFp(configuration).deleteVolumeRegistration(volumeId, region, namespace, xNomadToken, idempotencyToken, force, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} action The action to perform on the Volume (create, detach, delete).
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {string} [node] Specifies node to target volume operation for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachOrDeleteVolume(volumeId: string, action: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, node?: string, options?: any) {
            return VolumesApiFp(configuration).detachOrDeleteVolume(volumeId, action, region, namespace, xNomadToken, idempotencyToken, node, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {string} [pluginId] Filters volume lists by plugin ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalVolumes(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, pluginId?: string, options?: any) {
            return VolumesApiFp(configuration).getExternalVolumes(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, pluginId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {string} [pluginId] Filters volume lists by plugin ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshots(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, pluginId?: string, options?: any) {
            return VolumesApiFp(configuration).getSnapshots(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, pluginId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolume(volumeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
            return VolumesApiFp(configuration).getVolume(volumeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
         * @param {string} [wait] Provided with IndexParam to wait for change.
         * @param {string} [stale] If present, results will include stale reads.
         * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {number} [perPage] Maximum number of results to return.
         * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
         * @param {string} [nodeId] Filters volume lists by node ID.
         * @param {string} [pluginId] Filters volume lists by plugin ID.
         * @param {string} [type] Filters volume lists to a specific type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolumes(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, nodeId?: string, pluginId?: string, type?: string, options?: any) {
            return VolumesApiFp(configuration).getVolumes(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, nodeId, pluginId, type, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CSISnapshotCreateRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSnapshot(body: CSISnapshotCreateRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return VolumesApiFp(configuration).postSnapshot(body, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CSIVolumeRegisterRequest} body 
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVolume(body: CSIVolumeRegisterRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return VolumesApiFp(configuration).postVolume(body, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CSIVolumeRegisterRequest} body 
         * @param {string} volumeId Volume unique identifier.
         * @param {string} [region] Filters results based on the specified region.
         * @param {string} [namespace] Filters results based on the specified namespace.
         * @param {string} [xNomadToken] A Nomad ACL token.
         * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVolumeRegistration(body: CSIVolumeRegisterRequest, volumeId: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
            return VolumesApiFp(configuration).postVolumeRegistration(body, volumeId, region, namespace, xNomadToken, idempotencyToken, options)(fetch, basePath);
        },
    };
};

/**
 * VolumesApi - object-oriented interface
 * @export
 * @class VolumesApi
 * @extends {BaseAPI}
 */
export class VolumesApi extends BaseAPI {
    /**
     * 
     * @param {CSIVolumeCreateRequest} body 
     * @param {string} volumeId Volume unique identifier.
     * @param {string} action The action to perform on the Volume (create, detach, delete).
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public createVolume(body: CSIVolumeCreateRequest, volumeId: string, action: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return VolumesApiFp(this.configuration).createVolume(body, volumeId, action, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {string} [pluginId] Filters volume lists by plugin ID.
     * @param {string} [snapshotId] The ID of the snapshot to target.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public deleteSnapshot(region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, pluginId?: string, snapshotId?: string, options?: any) {
        return VolumesApiFp(this.configuration).deleteSnapshot(region, namespace, xNomadToken, idempotencyToken, pluginId, snapshotId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} volumeId Volume unique identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {string} [force] Used to force the de-registration of a volume.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public deleteVolumeRegistration(volumeId: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, force?: string, options?: any) {
        return VolumesApiFp(this.configuration).deleteVolumeRegistration(volumeId, region, namespace, xNomadToken, idempotencyToken, force, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} volumeId Volume unique identifier.
     * @param {string} action The action to perform on the Volume (create, detach, delete).
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {string} [node] Specifies node to target volume operation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public detachOrDeleteVolume(volumeId: string, action: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, node?: string, options?: any) {
        return VolumesApiFp(this.configuration).detachOrDeleteVolume(volumeId, action, region, namespace, xNomadToken, idempotencyToken, node, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {string} [pluginId] Filters volume lists by plugin ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public getExternalVolumes(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, pluginId?: string, options?: any) {
        return VolumesApiFp(this.configuration).getExternalVolumes(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, pluginId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {string} [pluginId] Filters volume lists by plugin ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public getSnapshots(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, pluginId?: string, options?: any) {
        return VolumesApiFp(this.configuration).getSnapshots(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, pluginId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} volumeId Volume unique identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public getVolume(volumeId: string, region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, options?: any) {
        return VolumesApiFp(this.configuration).getVolume(volumeId, region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {number} [index] If set, wait until query exceeds given index. Must be provided with WaitParam.
     * @param {string} [wait] Provided with IndexParam to wait for change.
     * @param {string} [stale] If present, results will include stale reads.
     * @param {string} [prefix] Constrains results to jobs that start with the defined prefix
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {number} [perPage] Maximum number of results to return.
     * @param {string} [nextToken] Indicates where to start paging for queries that support pagination.
     * @param {string} [nodeId] Filters volume lists by node ID.
     * @param {string} [pluginId] Filters volume lists by plugin ID.
     * @param {string} [type] Filters volume lists to a specific type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public getVolumes(region?: string, namespace?: string, index?: number, wait?: string, stale?: string, prefix?: string, xNomadToken?: string, perPage?: number, nextToken?: string, nodeId?: string, pluginId?: string, type?: string, options?: any) {
        return VolumesApiFp(this.configuration).getVolumes(region, namespace, index, wait, stale, prefix, xNomadToken, perPage, nextToken, nodeId, pluginId, type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CSISnapshotCreateRequest} body 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public postSnapshot(body: CSISnapshotCreateRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return VolumesApiFp(this.configuration).postSnapshot(body, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CSIVolumeRegisterRequest} body 
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public postVolume(body: CSIVolumeRegisterRequest, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return VolumesApiFp(this.configuration).postVolume(body, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CSIVolumeRegisterRequest} body 
     * @param {string} volumeId Volume unique identifier.
     * @param {string} [region] Filters results based on the specified region.
     * @param {string} [namespace] Filters results based on the specified namespace.
     * @param {string} [xNomadToken] A Nomad ACL token.
     * @param {string} [idempotencyToken] Can be used to ensure operations are only run once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumesApi
     */
    public postVolumeRegistration(body: CSIVolumeRegisterRequest, volumeId: string, region?: string, namespace?: string, xNomadToken?: string, idempotencyToken?: string, options?: any) {
        return VolumesApiFp(this.configuration).postVolumeRegistration(body, volumeId, region, namespace, xNomadToken, idempotencyToken, options)(this.fetch, this.basePath);
    }

}
